/*
 * Copyright (c) 2003-2009 jMonkeyEngine
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * * Neither the name of 'jMonkeyEngine' nor the names of its contributors 
 *   may be used to endorse or promote products derived from this software 
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.jme.intersection;

import java.nio.IntBuffer;

import com.jme.math.FastMath;
import com.jme.math.TransformMatrix;
import com.jme.math.Vector2f;
import com.jme.math.Vector3f;



/**
 * <code>Intersection</code> provides functional methods for calculating the
 * intersection of some objects. All the methods are static to allow for quick
 * and easy calls. <code>Intersection</code> relays requests to specific
 * classes to handle the actual work. By providing checks to just
 * <code>BoundingVolume</code> the client application need not worry about
 * what type of bounding volume is being used.
 * 
 * @author Mark Powell
 * @version $Id: Intersection.java 4131 2009-03-19 20:15:28Z blaine.dev $
 */
public class Intersection {

	/**
	 * EPSILON represents the error buffer used to denote a hit.
	 */
	public static final double EPSILON = 1e-12;

	private static final  Vector3f tempVa = new  Vector3f();

	private static final  Vector3f tempVb = new  Vector3f();

	private static final  Vector3f tempVc = new  Vector3f();

	private static final  Vector3f tempVd = new  Vector3f();

	private static final  Vector3f tempVe = new  Vector3f();

	private static final  float[] tempFa = new  float[2];

	private static final  float[] tempFb = new  float[2];

	private static final  Vector2f tempV2a = new  Vector2f();

	private static final  Vector2f tempV2b = new  Vector2f();

	/**
	 * This is a <b>VERY </b> brute force method of detecting if two TriMesh
	 * objects intersect.
	 * 
	 * @param mesh1
	 *            The first TriMesh.
	 * @param mesh2
	 *            The second TriMesh.
	 * @return True if they intersect, false otherwise.
	 */
	/* public static boolean meshIntersection(TriMesh mesh1, TriMesh mesh2) {

		IntBuffer indexA = mesh1.getIndexBuffer();
		IntBuffer indexB = mesh2.getIndexBuffer();
		TransformMatrix aTransform = new TransformMatrix();
		aTransform.setRotationQuaternion(mesh1.getWorldRotation());
		aTransform.setTranslation(mesh1.getWorldTranslation());
		aTransform.setScale(mesh1.getWorldScale());

		TransformMatrix bTransform = new TransformMatrix();
		bTransform.setRotationQuaternion(mesh2.getWorldRotation());
		bTransform.setTranslation(mesh2.getWorldTranslation());
		bTransform.setScale(mesh2.getWorldScale());

		Vector3f[] vertA = BufferUtils.getVector3Array(mesh1.getVertexBuffer());
		for (int i = 0; i < vertA.length; i++)
			aTransform.multPoint(vertA[i]);

		Vector3f[] vertB = BufferUtils.getVector3Array(mesh2.getVertexBuffer());
		for (int i = 0; i < vertB.length; i++)
			bTransform.multPoint(vertB[i]);

		for (int i = 0; i < mesh1.getTriangleCount(); i++) {
			for (int j = 0; j < mesh2.getTriangleCount(); j++) {
				if (intersection(vertA[indexA.get(i * 3 + 0)],
						vertA[indexA.get(i * 3 + 1)], vertA[indexA.get(i * 3 + 2)],
						vertB[indexB.get(j * 3 + 0)], vertB[indexB.get(j * 3 + 1)],
						vertB[indexB.get(j * 3 + 2)]))
					return true;
			}
		}
		return false;
	} */

	/**
	 * This method tests for the intersection between two triangles defined by
	 * their vertexes. Converted to java from C code found at
	 * http://www.acm.org/jgt/papers/Moller97/tritri.html
	 * 
	 * @param v0
	 *            First triangle's first vertex.
	 * @param v1
	 *            First triangle's second vertex.
	 * @param v2
	 *            First triangle's third vertex.
	 * @param u0
	 *            Second triangle's first vertex.
	 * @param u1
	 *            Second triangle's second vertex.
	 * @param u2
	 *            Second triangle's third vertex.
	 * @return True if the two triangles intersect, false otherwise.
	 */
	public static  boolean intersection( Vector3f v0,  Vector3f v1,  Vector3f v2,
			 Vector3f u0,  Vector3f u1,  Vector3f u2) {
		 Vector3f e1 = tempVa;
		 Vector3f e2 = tempVb;
		 Vector3f n1 = tempVc;
		 Vector3f n2 = tempVd;
		 float d1, d2;
		 float du0, du1, du2, dv0, dv1, dv2;
		 Vector3f d = tempVe;
		 float[] isect1 = tempFa;
		 float[] isect2 = tempFb;
		 float du0du1, du0du2, dv0dv1, dv0dv2;
		short index;
		 float vp0, vp1, vp2;
		 float up0, up1, up2;
		 float bb, cc, max;
		 float xx, yy, xxyy, tmp;

		n1.cross(n2, d);
		d.x = accept_all(d.x);
		max = Math.abs(d.x);

		return coplanarTriTri(n1, v0, v1, v2, u0, u1, u2);
	}


	private static  boolean coplanarTriTri( Vector3f n,  Vector3f v0,  Vector3f v1,
			 Vector3f v2,  Vector3f u0,  Vector3f u1,  Vector3f u2) {
		 Vector3f a = new  Vector3f();
		short i0, i1;
		n.x = accept_all(n.x); //tempVc.x
		a.x = Math.abs(n.x);
		return false;
	}


	public static boolean accept(boolean b) { return b; }
	public static float[] accept_all(float[] f) { return f; }
	public static float accept(float f) { return f; }
	public static float accept_all(float f) { return f; }
}

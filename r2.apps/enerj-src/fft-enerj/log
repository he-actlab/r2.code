Buildfile: /Users/jspark/projects/expax.code/apps/fft-enerj/build.xml

clean:

build:
    [mkdir] Created dir: /Users/jspark/projects/expax.code/apps/fft-enerj/build
   [enerjc] /Users/jspark/projects/expax.code/apps/fft-enerj/build.xml:40: warning: 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for repeatable builds
   [enerjc] Compiling 5 source files to /Users/jspark/projects/expax.code/apps/fft-enerj/build
   [enerjc] [parsing started RegularFileObject[/Users/jspark/projects/expax.code/apps/fft-enerj/src/jnt/scimark2/Constants.java]]
   [enerjc] [parsing completed 15ms]
   [enerjc] [parsing started RegularFileObject[/Users/jspark/projects/expax.code/apps/fft-enerj/src/jnt/scimark2/FFT.java]]
   [enerjc] [parsing completed 10ms]
   [enerjc] [parsing started RegularFileObject[/Users/jspark/projects/expax.code/apps/fft-enerj/src/jnt/scimark2/Random.java]]
   [enerjc] [parsing completed 7ms]
   [enerjc] [parsing started RegularFileObject[/Users/jspark/projects/expax.code/apps/fft-enerj/src/jnt/scimark2/commandline.java]]
   [enerjc] [parsing completed 1ms]
   [enerjc] [parsing started RegularFileObject[/Users/jspark/projects/expax.code/apps/fft-enerj/src/jnt/scimark2/kernel.java]]
   [enerjc] [parsing completed 3ms]
   [enerjc] [search path for source files: /Users/jspark/projects/expax.code/apps/fft-enerj/src]
   [enerjc] [search path for class files: /Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/resources.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/rt.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/sunrsasign.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jsse.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jce.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/charsets.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jfr.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/JObjC.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/classes,../../checker-runtime/build/cfrt.jar,../../enerj/build/enerj.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/dnsns.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/localedata.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunec.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/zipfs.jar,/System/Library/Java/Extensions/MRJToolkit.jar,/System/Library/Java/Extensions/QTJava.zip,/Users/jspark/projects/expax.code/apps/fft-enerj/build,/opt/local/share/java/apache-ant/lib/ant-launcher.jar,/opt/local/share/java/apache-ant/lib/ant-antlr.jar,/opt/local/share/java/apache-ant/lib/ant-apache-bcel.jar,/opt/local/share/java/apache-ant/lib/ant-apache-bsf.jar,/opt/local/share/java/apache-ant/lib/ant-apache-log4j.jar,/opt/local/share/java/apache-ant/lib/ant-apache-oro.jar,/opt/local/share/java/apache-ant/lib/ant-apache-regexp.jar,/opt/local/share/java/apache-ant/lib/ant-apache-resolver.jar,/opt/local/share/java/apache-ant/lib/ant-apache-xalan2.jar,/opt/local/share/java/apache-ant/lib/ant-commons-logging.jar,/opt/local/share/java/apache-ant/lib/ant-commons-net.jar,/opt/local/share/java/apache-ant/lib/ant-jai.jar,/opt/local/share/java/apache-ant/lib/ant-javamail.jar,/opt/local/share/java/apache-ant/lib/ant-jdepend.jar,/opt/local/share/java/apache-ant/lib/ant-jmf.jar,/opt/local/share/java/apache-ant/lib/ant-jsch.jar,/opt/local/share/java/apache-ant/lib/ant-junit.jar,/opt/local/share/java/apache-ant/lib/ant-junit4.jar,/opt/local/share/java/apache-ant/lib/ant-netrexx.jar,/opt/local/share/java/apache-ant/lib/ant-swing.jar,/opt/local/share/java/apache-ant/lib/ant-testutil.jar,/opt/local/share/java/apache-ant/lib/ant.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/tools.jar]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/util/Properties.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class)]]
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/lang/Approx.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Annotation.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar(java/lang/annotation/ElementType.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar(checkers/quals/SubtypeOf.class)]]
   [enerjc] Round 1:
   [enerjc] 	input files: {jnt.scimark2.Constants, jnt.scimark2.FFT, jnt.scimark2.Random, jnt.scimark2.commandline, jnt.scimark2.kernel}
   [enerjc] 	annotations: []
   [enerjc] 	last round: false
   [enerjc] *** EXPAX_PC: value = mbstatic,simulation
   [enerjc] *** EXPAX_PC: ENERJ
   [enerjc] *** EXPAX_PC: MethodBindingTranslator start!
   [enerjc] Processor enerj.PrecisionChecker matches [] and returns false.
   [enerjc] [search path for source files: /Users/jspark/projects/expax.code/apps/fft-enerj/src]
   [enerjc] [search path for class files: /Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/resources.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/rt.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/sunrsasign.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jsse.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jce.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/charsets.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jfr.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/JObjC.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/classes,../../checker-runtime/build/cfrt.jar,../../enerj/build/enerj.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/dnsns.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/localedata.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunec.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/zipfs.jar,/System/Library/Java/Extensions/MRJToolkit.jar,/System/Library/Java/Extensions/QTJava.zip,/Users/jspark/projects/expax.code/apps/fft-enerj/build,/opt/local/share/java/apache-ant/lib/ant-launcher.jar,/opt/local/share/java/apache-ant/lib/ant-antlr.jar,/opt/local/share/java/apache-ant/lib/ant-apache-bcel.jar,/opt/local/share/java/apache-ant/lib/ant-apache-bsf.jar,/opt/local/share/java/apache-ant/lib/ant-apache-log4j.jar,/opt/local/share/java/apache-ant/lib/ant-apache-oro.jar,/opt/local/share/java/apache-ant/lib/ant-apache-regexp.jar,/opt/local/share/java/apache-ant/lib/ant-apache-resolver.jar,/opt/local/share/java/apache-ant/lib/ant-apache-xalan2.jar,/opt/local/share/java/apache-ant/lib/ant-commons-logging.jar,/opt/local/share/java/apache-ant/lib/ant-commons-net.jar,/opt/local/share/java/apache-ant/lib/ant-jai.jar,/opt/local/share/java/apache-ant/lib/ant-javamail.jar,/opt/local/share/java/apache-ant/lib/ant-jdepend.jar,/opt/local/share/java/apache-ant/lib/ant-jmf.jar,/opt/local/share/java/apache-ant/lib/ant-jsch.jar,/opt/local/share/java/apache-ant/lib/ant-junit.jar,/opt/local/share/java/apache-ant/lib/ant-junit4.jar,/opt/local/share/java/apache-ant/lib/ant-netrexx.jar,/opt/local/share/java/apache-ant/lib/ant-swing.jar,/opt/local/share/java/apache-ant/lib/ant-testutil.jar,/opt/local/share/java/apache-ant/lib/ant.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/tools.jar]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/util/Properties.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class)]]
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/lang/Approx.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Annotation.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar(java/lang/annotation/ElementType.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar(checkers/quals/SubtypeOf.class)]]
   [enerjc] Round 2:
   [enerjc] 	input files: {}
   [enerjc] 	annotations: []
   [enerjc] 	last round: true
   [enerjc] [search path for source files: /Users/jspark/projects/expax.code/apps/fft-enerj/src]
   [enerjc] [search path for class files: /Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/resources.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/rt.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/sunrsasign.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jsse.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jce.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/charsets.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/jfr.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/JObjC.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/classes,../../checker-runtime/build/cfrt.jar,../../enerj/build/enerj.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/dnsns.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/localedata.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunec.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/jre/lib/ext/zipfs.jar,/System/Library/Java/Extensions/MRJToolkit.jar,/System/Library/Java/Extensions/QTJava.zip,/Users/jspark/projects/expax.code/apps/fft-enerj/build,/opt/local/share/java/apache-ant/lib/ant-launcher.jar,/opt/local/share/java/apache-ant/lib/ant-antlr.jar,/opt/local/share/java/apache-ant/lib/ant-apache-bcel.jar,/opt/local/share/java/apache-ant/lib/ant-apache-bsf.jar,/opt/local/share/java/apache-ant/lib/ant-apache-log4j.jar,/opt/local/share/java/apache-ant/lib/ant-apache-oro.jar,/opt/local/share/java/apache-ant/lib/ant-apache-regexp.jar,/opt/local/share/java/apache-ant/lib/ant-apache-resolver.jar,/opt/local/share/java/apache-ant/lib/ant-apache-xalan2.jar,/opt/local/share/java/apache-ant/lib/ant-commons-logging.jar,/opt/local/share/java/apache-ant/lib/ant-commons-net.jar,/opt/local/share/java/apache-ant/lib/ant-jai.jar,/opt/local/share/java/apache-ant/lib/ant-javamail.jar,/opt/local/share/java/apache-ant/lib/ant-jdepend.jar,/opt/local/share/java/apache-ant/lib/ant-jmf.jar,/opt/local/share/java/apache-ant/lib/ant-jsch.jar,/opt/local/share/java/apache-ant/lib/ant-junit.jar,/opt/local/share/java/apache-ant/lib/ant-junit4.jar,/opt/local/share/java/apache-ant/lib/ant-netrexx.jar,/opt/local/share/java/apache-ant/lib/ant-swing.jar,/opt/local/share/java/apache-ant/lib/ant-testutil.jar,/opt/local/share/java/apache-ant/lib/ant.jar,/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/tools.jar]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/util/Properties.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class)]]
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/lang/Approx.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Annotation.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar(java/lang/annotation/ElementType.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar(checkers/quals/SubtypeOf.class)]]
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/lang/Precise.class)]]
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/lang/Top.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar(checkers/quals/ImplicitFor.class)]]
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/lang/Context.class)]]
   [enerjc] [checking jnt.scimark2.Constants]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar(checkers/quals/PolyAll.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Users/jspark/projects/expax.code/checker-framework/checkers/binary/jsr308-all.jar(checkers/quals/Unqualified.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/util/Vector.class)]]
   [enerjc] *** EXPAX_PC: MethodBindingTranslator end!
   [enerjc] *** EXPAX_PC: RuntimePrecisionTranslator start!
   [enerjc] *** EXPAX_RPT: class name is changed to = jnt.scimark2.Constants
   [enerjc] *** EXPAX_RPT: method name is changed to =  
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public <init>() {
   [enerjc]     super();
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to <init>()
   [enerjc] *** EXPAX_PC: RuntimePrecisionTranslator end!
   [enerjc] *** EXPAX_PC: SimulationTranslator start!
   [enerjc] *** EXPAX_ST: visitSelect: tree = jnt.scimark2
   [enerjc] *** EXPAX_ST: visitIdent: tree = jnt
   [enerjc] *** EXPAX_ST: lvalues contains jnt
   [enerjc] *** EXPAX_ST: lvalues contains = jnt.scimark2
   [enerjc] *** EXPAX_PRT: class name is changed to = jnt.scimark2.Constants
   [enerjc] *** EXPAX_RPT: method name is changed to =  
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public <init>() {
   [enerjc]     super();
   [enerjc]     enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor(this);
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to <init>()
   [enerjc] *** EXPAX_ST: visitIdent: tree = super
   [enerjc] *** EXPAX_ST: lvalues contains super
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final double RESOLUTION_DEFAULT = 2.0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static double RESOLUTION_DEFAULT = 2.0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int RANDOM_SEED = 101010
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int RANDOM_SEED = 101010
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int FFT_SIZE = 1024
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int FFT_SIZE = 1024
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int SOR_SIZE = 100
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int SOR_SIZE = 100
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int SPARSE_SIZE_M = 1000
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int SPARSE_SIZE_M = 1000
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int SPARSE_SIZE_nz = 5000
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int SPARSE_SIZE_nz = 5000
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int LU_SIZE = 100
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int LU_SIZE = 100
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int LG_FFT_SIZE = 1048576
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int LG_FFT_SIZE = 1048576
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int LG_SOR_SIZE = 1000
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int LG_SOR_SIZE = 1000
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int LG_SPARSE_SIZE_M = 100000
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/rt/PrecisionRuntimeRoot.class)]]
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/rt/PrecisionRuntime.class)]]
   [enerjc] *** EXPAX_PRT: approx is false = public static int LG_SPARSE_SIZE_M = 100000
   [enerjc] [loading ZipFileIndexFileObject[../../checker-runtime/build/cfrt.jar(checkers/runtime/rt/Runtime.class)]]
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int LG_SPARSE_SIZE_nz = 1000000
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Double.class)]]
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/rt/PrecisionRuntime$MemKind.class)]]
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Number.class)]]
   [enerjc] *** EXPAX_PRT: approx is false = public static int LG_SPARSE_SIZE_nz = 1000000
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Integer.class)]]
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int LG_LU_SIZE = 1000
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Byte.class)]]
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Character.class)]]
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Short.class)]]
   [enerjc] *** EXPAX_PRT: approx is false = public static int LG_LU_SIZE = 1000
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Long.class)]]
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int TINY_FFT_SIZE = 16
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Float.class)]]
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] [wrote RegularFileObject[/Users/jspark/projects/expax.code/apps/fft-enerj/build/jnt/scimark2/Constants.class]]
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] [checking jnt.scimark2.FFT]
   [enerjc] *** EXPAX_PRT: approx is false = public static int TINY_FFT_SIZE = 16
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Error.class)]]
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int TINY_SOR_SIZE = 10
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class)]]
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Math.class)]]
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/lang/Endorsements.class)]]
   [enerjc] *** EXPAX_PRT: approx is false = public static int TINY_SOR_SIZE = 10
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int TINY_SPARSE_SIZE_M = 10
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int TINY_SPARSE_SIZE_M = 10
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int TINY_SPARSE_SIZE_N = 10
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int TINY_SPARSE_SIZE_N = 10
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int TINY_SPARSE_SIZE_nz = 50
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int TINY_SPARSE_SIZE_nz = 50
   [enerjc] *** EXPAX_ST: visitVarDef: tree = public static final int TINY_LU_SIZE = 10
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = public static int TINY_LU_SIZE = 10
   [enerjc] *** EXPAX_PC: SimulationTranslator end!
   [enerjc] *** EXPAX_PC: ENERJ
   [enerjc] *** EXPAX_PC: MethodBindingTranslator start!
   [enerjc] *** EXPAX_PC: MethodBindingTranslator end!
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Thread.class)]]
   [enerjc] *** EXPAX_PC: RuntimePrecisionTranslator start!
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/rt/Reference.class)]]
   [enerjc] *** EXPAX_RPT: class name is changed to = jnt.scimark2.FFT
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/rt/PrecisionRuntime$ArithOperator.class)]]
   [enerjc] *** EXPAX_RPT: method name is changed to =  
   [enerjc] [loading ZipFileIndexFileObject[../../enerj/build/enerj.jar(enerj/rt/PrecisionRuntime$NumberKind.class)]]
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/io/Serializable.class)]]
   [enerjc] public <init>() {
   [enerjc]     super();
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to <init>()
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public static void transform(@Approx()
   [enerjc] double[] data) {
   [enerjc]     transform_internal(data, -1);
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to transform(double[])
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public static void inverse(@Approx()
   [enerjc] double[] data) {
   [enerjc]     transform_internal(data, +1);
   [enerjc]     int nd = data.length;
   [enerjc]     int n = nd / 2;
   [enerjc]     @Approx()
   [enerjc]     int aprN = n;
   [enerjc]     @Approx()
   [enerjc]     double norm = 1.0 / aprN;
   [enerjc]     for (int i = 0; i < nd; i++) data[i] *= norm;
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to inverse(double[])
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] protected static int log2(int n) {
   [enerjc]     int log = 0;
   [enerjc]     for (int k = 1; k < n; k *= 2, log++) ;
   [enerjc]     if (n != (1 << log)) throw new Error("FFT: Data length is not a power of 2!: " + n);
   [enerjc]     return log;
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to log2(int)
   [enerjc] *** EXPAX_RPT: visitNewClass = new Error("FFT: Data length is not a power of 2!: " + n)
   [enerjc] *** EXPAX_PC: objectSizes called - type = @Precise Error
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 8
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] protected static void transform_internal(@Approx()
   [enerjc] double[] data, int direction) {
   [enerjc]     if (data.length == 0) return;
   [enerjc]     int n = data.length / 2;
   [enerjc]     if (n == 1) return;
   [enerjc]     int logn = log2(n);
   [enerjc]     bitreverse(data);
   [enerjc]     for (int bit = 0, dual = 1; bit < logn; bit++, dual *= 2) {
   [enerjc]         @Approx()
   [enerjc]         double w_real = 1.0;
   [enerjc]         @Approx()
   [enerjc]         double w_imag = 0.0;
   [enerjc]         @Approx()
   [enerjc]         double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);
   [enerjc]         @Approx()
   [enerjc]         double s = Math.sin(Endorsements.endorse(theta));
   [enerjc]         @Approx()
   [enerjc]         double t = Math.sin(Endorsements.endorse(theta / 2.0));
   [enerjc]         @Approx()
   [enerjc]         double s2 = 2.0 * t * t;
   [enerjc]         for (int b = 0; b < n; b += 2 * dual) {
   [enerjc]             int i = 2 * b;
   [enerjc]             int j = 2 * (b + dual);
   [enerjc]             @Approx()
   [enerjc]             double wd_real = data[j];
   [enerjc]             @Approx()
   [enerjc]             double wd_imag = data[j + 1];
   [enerjc]             data[j] = data[i] - wd_real;
   [enerjc]             data[j + 1] = data[i + 1] - wd_imag;
   [enerjc]             data[i] += wd_real;
   [enerjc]             data[i + 1] += wd_imag;
   [enerjc]         }
   [enerjc]         for (int a = 1; a < dual; a++) {
   [enerjc]             {
   [enerjc]                 @Approx()
   [enerjc]                 double tmp_real = w_real - s * w_imag - s2 * w_real;
   [enerjc]                 @Approx()
   [enerjc]                 double tmp_imag = w_imag + s * w_real - s2 * w_imag;
   [enerjc]                 w_real = tmp_real;
   [enerjc]                 w_imag = tmp_imag;
   [enerjc]             }
   [enerjc]             for (int b = 0; b < n; b += 2 * dual) {
   [enerjc]                 int i = 2 * (b + a);
   [enerjc]                 int j = 2 * (b + a + dual);
   [enerjc]                 @Approx()
   [enerjc]                 double z1_real = data[j];
   [enerjc]                 @Approx()
   [enerjc]                 double z1_imag = data[j + 1];
   [enerjc]                 @Approx()
   [enerjc]                 double wd_real = w_real * z1_real - w_imag * z1_imag;
   [enerjc]                 @Approx()
   [enerjc]                 double wd_imag = w_real * z1_imag + w_imag * z1_real;
   [enerjc]                 data[j] = data[i] - wd_real;
   [enerjc]                 data[j + 1] = data[i + 1] - wd_imag;
   [enerjc]                 data[i] += wd_real;
   [enerjc]                 data[i + 1] += wd_imag;
   [enerjc]             }
   [enerjc]         }
   [enerjc]     }
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to transform_internal(double[],int)
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] protected static void bitreverse(@Approx()
   [enerjc] double[] data) {
   [enerjc]     int n = data.length / 2;
   [enerjc]     int nm1 = n - 1;
   [enerjc]     int i = 0;
   [enerjc]     int j = 0;
   [enerjc]     for (; i < nm1; i++) {
   [enerjc]         int ii = i << 1;
   [enerjc]         int jj = j << 1;
   [enerjc]         int k = n >> 1;
   [enerjc]         if (i < j) {
   [enerjc]             @Approx()
   [enerjc]             double tmp_real = data[ii];
   [enerjc]             @Approx()
   [enerjc]             double tmp_imag = data[ii + 1];
   [enerjc]             data[ii] = data[jj];
   [enerjc]             data[ii + 1] = data[jj + 1];
   [enerjc]             data[jj] = tmp_real;
   [enerjc]             data[jj + 1] = tmp_imag;
   [enerjc]         }
   [enerjc]         while (k <= j) {
   [enerjc]             j -= k;
   [enerjc]             k >>= 1;
   [enerjc]         }
   [enerjc]         j += k;
   [enerjc]     }
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to bitreverse(double[])
   [enerjc] *** EXPAX_PC: RuntimePrecisionTranslator end!
   [enerjc] *** EXPAX_PC: SimulationTranslator start!
   [enerjc] *** EXPAX_ST: visitSelect: tree = jnt.scimark2
   [enerjc] *** EXPAX_ST: visitIdent: tree = jnt
   [enerjc] *** EXPAX_ST: lvalues contains jnt
   [enerjc] *** EXPAX_ST: lvalues contains = jnt.scimark2
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.lang.*
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.lang
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.lang
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.lang.*
   [enerjc] *** EXPAX_PRT: class name is changed to = jnt.scimark2.FFT
   [enerjc] *** EXPAX_RPT: method name is changed to =  
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public <init>() {
   [enerjc]     super();
   [enerjc]     enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor(this);
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to <init>()
   [enerjc] *** EXPAX_ST: visitIdent: tree = super
   [enerjc] *** EXPAX_ST: lvalues contains super
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public static void transform(@Approx()
   [enerjc] double[] data) {
   [enerjc]     transform_internal(data, -1);
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to transform(double[])
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<double[]> data__REF__ = new <double[]>enerj.rt.Reference<double[]>(data, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitIdent: tree = transform_internal
   [enerjc] *** EXPAX_ST: lvalues contains transform_internal
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public static void inverse(@Approx()
   [enerjc] double[] data) {
   [enerjc]     transform_internal(data, +1);
   [enerjc]     int nd = data.length;
   [enerjc]     int n = nd / 2;
   [enerjc]     @Approx()
   [enerjc]     int aprN = n;
   [enerjc]     @Approx()
   [enerjc]     double norm = 1.0 / aprN;
   [enerjc]     for (int i = 0; i < nd; i++) data[i] *= norm;
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to inverse(double[])
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_PRT: createNewInitializer = int nd = data.length
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int nd = data.length
   [enerjc] *** EXPAX_PRT: createNewInitializer = int n = nd / 2
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int n = nd / 2
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] int aprN = n
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] int aprN = n
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 1
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] int aprN = n
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double norm = 1.0 / aprN
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double norm = 1.0 / aprN
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 2
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double norm = 1.0 / aprN
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<double[]> data__REF__ = new <double[]>enerj.rt.Reference<double[]>(data, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitIdent: tree = transform_internal
   [enerjc] *** EXPAX_ST: lvalues contains transform_internal
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitUnary: tree = +1
   [enerjc] *** EXPAX_ST: visitUnary: tag = POS
   [enerjc] *** EXPAX_ST: visitUnary: kind = UNARY_PLUS
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int nd = data.length
   [enerjc] *** EXPAX_ST: visitSelect: tree = data.length
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int nd = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false).length
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> nd__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(nd, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int n = nd / 2
   [enerjc] *** EXPAX_ST: visitBinary: tree = nd / 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is false = DIV
   [enerjc] *** EXPAX_PRT: approx is false = nd / 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = nd
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = nd
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int n = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(nd__REF__, false).intValue(), 2, enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> n__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(n, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] int aprN = n
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitIdent: tree = n
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = n
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] int aprN = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(n__REF__, false).intValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 3
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] int aprN = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(n__REF__, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Integer> aprN__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(aprN, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double norm = 1.0 / aprN
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitBinary: tree = 1.0 / aprN
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is true = DIV
   [enerjc] *** EXPAX_PRT: approx is true = 1.0 / aprN
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 4
   [enerjc] *** EXPAX_ST: visitIdent: tree = aprN
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = aprN
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 5
   [enerjc] *** ENERJ_APPROX(loadlocal): aprN
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Boolean.class)]]
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): 1.0 / enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(aprN__REF__, true).intValue()
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double norm = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(1.0, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(aprN__REF__, true).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 6
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double norm = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(1.0, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(aprN__REF__, true).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> norm__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(norm, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_PRT: createNewInitializer = int i = 0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int i = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> i__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(i, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = i < nd
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = i < nd
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = nd
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = nd
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitUnary: tree = i++
   [enerjc] *** EXPAX_ST: visitUnary: tag = POSTINC
   [enerjc] *** EXPAX_ST: visitUnary: kind = POSTFIX_INCREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: lvalues contains i
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitAssignop: tree = data[i] *= norm
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[i]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[i])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = norm
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = norm
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 7
   [enerjc] *** ENERJ_APPROX(loadlocal): norm
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #2
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] protected static int log2(int n) {
   [enerjc]     int log = 0;
   [enerjc]     for (int k = 1; k < n; k *= 2, log++) ;
   [enerjc]     if (n != (1 << log)) throw enerj.rt.PrecisionRuntimeRoot.impl.wrappedNew(enerj.rt.PrecisionRuntimeRoot.impl.beforeCreation(Thread.currentThread(), false, 16, 0), new Error("FFT: Data length is not a power of 2!: " + n), Thread.currentThread());
   [enerjc]     return log;
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to log2(int)
   [enerjc] *** EXPAX_PRT: createNewInitializer = int n
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int n
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int n
   [enerjc] *** EXPAX_PRT: createNewInitializer = int log = 0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int log = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> n__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(n, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int log = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int log = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> log__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(log, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_PRT: createNewInitializer = int k = 1
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int k = 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int k = 1
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int k = 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> k__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(k, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = k < n
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = k < n
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: visitIdent: tree = n
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = n
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitAssignop: tree = k *= 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: lvalues contains k
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: visitUnary: tree = log++
   [enerjc] *** EXPAX_ST: visitUnary: tag = POSTINC
   [enerjc] *** EXPAX_ST: visitUnary: kind = POSTFIX_INCREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = log
   [enerjc] *** EXPAX_ST: visitIdent: tree = log
   [enerjc] *** EXPAX_ST: lvalues contains log
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = log
   [enerjc] *** EXPAX_ST: visitBinary: tree = n != (1 << log)
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = NE
   [enerjc] *** EXPAX_ST: kind = NOT_EQUAL_TO
   [enerjc] *** EXPAX_PRT: approx is false = NE
   [enerjc] *** EXPAX_PRT: approx is false = n != (1 << log)
   [enerjc] *** EXPAX_ST: visitIdent: tree = n
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = n
   [enerjc] *** EXPAX_ST: visitBinary: tree = 1 << log
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = SL
   [enerjc] *** EXPAX_ST: kind = LEFT_SHIFT
   [enerjc] *** EXPAX_PRT: approx is false = SL
   [enerjc] *** EXPAX_PRT: approx is false = 1 << log
   [enerjc] *** EXPAX_ST: visitIdent: tree = log
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = log
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.wrappedNew
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.beforeCreation
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitSelect: tree = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitIdent: tree = Thread
   [enerjc] *** EXPAX_ST: lvalues contains Thread
   [enerjc] *** EXPAX_ST: lvalues contains = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitIdent: tree = Error
   [enerjc] *** EXPAX_ST: lvalues contains Error
   [enerjc] *** EXPAX_ST: visitBinary: tree = "FFT: Data length is not a power of 2!: " + n
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = "FFT: Data length is not a power of 2!: " + n
   [enerjc] *** EXPAX_ST: visitIdent: tree = n
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = n
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitSelect: tree = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitIdent: tree = Thread
   [enerjc] *** EXPAX_ST: lvalues contains Thread
   [enerjc] *** EXPAX_ST: lvalues contains = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitIdent: tree = log
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = log
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] protected static void transform_internal(@Approx()
   [enerjc] double[] data, int direction) {
   [enerjc]     if (data.length == 0) return;
   [enerjc]     int n = data.length / 2;
   [enerjc]     if (n == 1) return;
   [enerjc]     int logn = log2(n);
   [enerjc]     bitreverse(data);
   [enerjc]     for (int bit = 0, dual = 1; bit < logn; bit++, dual *= 2) {
   [enerjc]         @Approx()
   [enerjc]         double w_real = 1.0;
   [enerjc]         @Approx()
   [enerjc]         double w_imag = 0.0;
   [enerjc]         @Approx()
   [enerjc]         double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);
   [enerjc]         @Approx()
   [enerjc]         double s = Math.sin(Endorsements.endorse(theta));
   [enerjc]         @Approx()
   [enerjc]         double t = Math.sin(Endorsements.endorse(theta / 2.0));
   [enerjc]         @Approx()
   [enerjc]         double s2 = 2.0 * t * t;
   [enerjc]         for (int b = 0; b < n; b += 2 * dual) {
   [enerjc]             int i = 2 * b;
   [enerjc]             int j = 2 * (b + dual);
   [enerjc]             @Approx()
   [enerjc]             double wd_real = data[j];
   [enerjc]             @Approx()
   [enerjc]             double wd_imag = data[j + 1];
   [enerjc]             data[j] = data[i] - wd_real;
   [enerjc]             data[j + 1] = data[i + 1] - wd_imag;
   [enerjc]             data[i] += wd_real;
   [enerjc]             data[i + 1] += wd_imag;
   [enerjc]         }
   [enerjc]         for (int a = 1; a < dual; a++) {
   [enerjc]             {
   [enerjc]                 @Approx()
   [enerjc]                 double tmp_real = w_real - s * w_imag - s2 * w_real;
   [enerjc]                 @Approx()
   [enerjc]                 double tmp_imag = w_imag + s * w_real - s2 * w_imag;
   [enerjc]                 w_real = tmp_real;
   [enerjc]                 w_imag = tmp_imag;
   [enerjc]             }
   [enerjc]             for (int b = 0; b < n; b += 2 * dual) {
   [enerjc]                 int i = 2 * (b + a);
   [enerjc]                 int j = 2 * (b + a + dual);
   [enerjc]                 @Approx()
   [enerjc]                 double z1_real = data[j];
   [enerjc]                 @Approx()
   [enerjc]                 double z1_imag = data[j + 1];
   [enerjc]                 @Approx()
   [enerjc]                 double wd_real = w_real * z1_real - w_imag * z1_imag;
   [enerjc]                 @Approx()
   [enerjc]                 double wd_imag = w_real * z1_imag + w_imag * z1_real;
   [enerjc]                 data[j] = data[i] - wd_real;
   [enerjc]                 data[j + 1] = data[i + 1] - wd_imag;
   [enerjc]                 data[i] += wd_real;
   [enerjc]                 data[i + 1] += wd_imag;
   [enerjc]             }
   [enerjc]         }
   [enerjc]     }
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to transform_internal(double[],int)
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_PRT: createNewInitializer = int direction
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int direction
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int direction
   [enerjc] *** EXPAX_PRT: createNewInitializer = int n = data.length / 2
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int n = data.length / 2
   [enerjc] *** EXPAX_PRT: createNewInitializer = int logn = log2(n)
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int logn = log2(n)
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> direction__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(direction, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<double[]> data__REF__ = new <double[]>enerj.rt.Reference<double[]>(data, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = data.length == 0
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = EQ
   [enerjc] *** EXPAX_ST: kind = EQUAL_TO
   [enerjc] *** EXPAX_PRT: approx is false = EQ
   [enerjc] *** EXPAX_PRT: approx is false = data.length == 0
   [enerjc] *** EXPAX_ST: visitSelect: tree = data.length
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int n = data.length / 2
   [enerjc] *** EXPAX_ST: visitBinary: tree = data.length / 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is false = DIV
   [enerjc] *** EXPAX_PRT: approx is false = data.length / 2
   [enerjc] *** EXPAX_ST: visitSelect: tree = data.length
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int n = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false).length, 2, enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> n__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(n, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = n == 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = EQ
   [enerjc] *** EXPAX_ST: kind = EQUAL_TO
   [enerjc] *** EXPAX_PRT: approx is false = EQ
   [enerjc] *** EXPAX_PRT: approx is false = n == 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = n
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = n
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int logn = log2(n)
   [enerjc] *** EXPAX_ST: visitIdent: tree = log2
   [enerjc] *** EXPAX_ST: lvalues contains log2
   [enerjc] *** EXPAX_ST: visitIdent: tree = n
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = n
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int logn = log2(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(n__REF__, false).intValue())
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> logn__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(logn, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitIdent: tree = bitreverse
   [enerjc] *** EXPAX_ST: lvalues contains bitreverse
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_PRT: createNewInitializer = int bit = 0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int bit = 0
   [enerjc] *** EXPAX_PRT: createNewInitializer = int dual = 1
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int dual = 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int bit = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int bit = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> bit__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(bit, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int dual = 1
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int dual = 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> dual__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(dual, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = bit < logn
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = bit < logn
   [enerjc] *** EXPAX_ST: visitIdent: tree = bit
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = bit
   [enerjc] *** EXPAX_ST: visitIdent: tree = logn
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = logn
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitUnary: tree = bit++
   [enerjc] *** EXPAX_ST: visitUnary: tag = POSTINC
   [enerjc] *** EXPAX_ST: visitUnary: kind = POSTFIX_INCREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = bit
   [enerjc] *** EXPAX_ST: visitIdent: tree = bit
   [enerjc] *** EXPAX_ST: lvalues contains bit
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = bit
   [enerjc] *** EXPAX_ST: visitAssignop: tree = dual *= 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = dual
   [enerjc] *** EXPAX_ST: lvalues contains dual
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = dual
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double w_real = 1.0
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double w_real = 1.0
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 8
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double w_real = 1.0
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double w_imag = 0.0
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double w_imag = 0.0
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 9
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double w_imag = 0.0
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual)
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual)
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 10
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual)
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double s = Math.sin(Endorsements.endorse(theta))
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double s = Math.sin(Endorsements.endorse(theta))
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 11
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double s = Math.sin(Endorsements.endorse(theta))
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double t = Math.sin(Endorsements.endorse(theta / 2.0))
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double t = Math.sin(Endorsements.endorse(theta / 2.0))
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 12
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double t = Math.sin(Endorsements.endorse(theta / 2.0))
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double s2 = 2.0 * t * t
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double s2 = 2.0 * t * t
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 13
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double s2 = 2.0 * t * t
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Class.class)]]
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double w_real = 1.0
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double w_real = 1.0
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 14
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double w_real = 1.0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> w_real__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(w_real, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double w_imag = 0.0
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double w_imag = 0.0
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 15
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double w_imag = 0.0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> w_imag__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(w_imag, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual)
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2.0 * direction * Math.PI / (2.0 * (double)dual)
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is true = DIV
   [enerjc] *** EXPAX_PRT: approx is true = 2.0 * direction * Math.PI / (2.0 * (double)dual)
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 16
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2.0 * direction * Math.PI
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = 2.0 * direction * Math.PI
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 17
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2.0 * direction
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = 2.0 * direction
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 18
   [enerjc] *** EXPAX_ST: visitIdent: tree = direction
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = direction
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): 2.0 * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(direction__REF__, false).intValue()
   [enerjc] *** EXPAX_ST: visitSelect: tree = Math.PI
   [enerjc] *** EXPAX_ST: visitIdent: tree = Math
   [enerjc] *** EXPAX_ST: lvalues contains Math
   [enerjc] *** EXPAX_ST: call isApprox - visitSelect
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = Math.PI
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2.0, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(direction__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue() * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadField(Math.class, "PI", false).doubleValue()
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2.0 * (double)dual
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = 2.0 * (double)dual
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 19
   [enerjc] *** EXPAX_ST: visitIdent: tree = dual
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = dual
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): 2.0 * (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(dual__REF__, false).intValue()
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2.0, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(direction__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadField(Math.class, "PI", false).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue() / (enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2.0, (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(dual__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue())
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double theta = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2.0, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(direction__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadField(Math.class, "PI", false).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), (enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2.0, (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(dual__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()), enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 20
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double theta = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2.0, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(direction__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadField(Math.class, "PI", false).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), (enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2.0, (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(dual__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()), enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> theta__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(theta, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double s = Math.sin(Endorsements.endorse(theta))
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitSelect: tree = Math.sin
   [enerjc] *** EXPAX_ST: visitIdent: tree = Math
   [enerjc] *** EXPAX_ST: lvalues contains Math
   [enerjc] *** EXPAX_ST: lvalues contains = Math.sin
   [enerjc] *** EXPAX_ST: visitSelect: tree = Endorsements.endorse
   [enerjc] *** EXPAX_ST: visitIdent: tree = Endorsements
   [enerjc] *** EXPAX_ST: lvalues contains Endorsements
   [enerjc] *** EXPAX_ST: lvalues contains = Endorsements.endorse
   [enerjc] *** EXPAX_ST: visitIdent: tree = theta
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = theta
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 21
   [enerjc] *** ENERJ_APPROX(loadlocal): theta
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double s = Math.sin(Endorsements.endorse(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(theta__REF__, true).doubleValue()))
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 22
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double s = Math.sin(Endorsements.endorse(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(theta__REF__, true).doubleValue()))
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> s__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(s, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double t = Math.sin(Endorsements.endorse(theta / 2.0))
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitSelect: tree = Math.sin
   [enerjc] *** EXPAX_ST: visitIdent: tree = Math
   [enerjc] *** EXPAX_ST: lvalues contains Math
   [enerjc] *** EXPAX_ST: lvalues contains = Math.sin
   [enerjc] *** EXPAX_ST: visitSelect: tree = Endorsements.endorse
   [enerjc] *** EXPAX_ST: visitIdent: tree = Endorsements
   [enerjc] *** EXPAX_ST: lvalues contains Endorsements
   [enerjc] *** EXPAX_ST: lvalues contains = Endorsements.endorse
   [enerjc] *** EXPAX_ST: visitBinary: tree = theta / 2.0
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is true = DIV
   [enerjc] *** EXPAX_PRT: approx is true = theta / 2.0
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 23
   [enerjc] *** EXPAX_ST: visitIdent: tree = theta
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = theta
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 24
   [enerjc] *** ENERJ_APPROX(loadlocal): theta
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(theta__REF__, true).doubleValue() / 2.0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double t = Math.sin(Endorsements.endorse(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(theta__REF__, true).doubleValue(), 2.0, enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()))
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 25
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double t = Math.sin(Endorsements.endorse(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(theta__REF__, true).doubleValue(), 2.0, enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()))
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> t__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(t, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double s2 = 2.0 * t * t
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2.0 * t * t
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = 2.0 * t * t
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 26
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2.0 * t
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = 2.0 * t
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 27
   [enerjc] *** EXPAX_ST: visitIdent: tree = t
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = t
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 28
   [enerjc] *** ENERJ_APPROX(loadlocal): t
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): 2.0 * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(t__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitIdent: tree = t
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = t
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 29
   [enerjc] *** ENERJ_APPROX(loadlocal): t
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2.0, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(t__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue() * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(t__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double s2 = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2.0, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(t__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(t__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 30
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double s2 = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2.0, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(t__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(t__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> s2__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(s2, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_PRT: createNewInitializer = int b = 0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int b = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int b = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int b = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> b__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(b, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = b < n
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = b < n
   [enerjc] *** EXPAX_ST: visitIdent: tree = b
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = b
   [enerjc] *** EXPAX_ST: visitIdent: tree = n
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = n
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitAssignop: tree = b += 2 * dual
   [enerjc] *** EXPAX_ST: visitIdent: tree = b
   [enerjc] *** EXPAX_ST: lvalues contains b
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2 * dual
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = 2 * dual
   [enerjc] *** EXPAX_ST: visitIdent: tree = dual
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = dual
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = b
   [enerjc] *** EXPAX_PRT: createNewInitializer = int i = 2 * b
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 2 * b
   [enerjc] *** EXPAX_PRT: createNewInitializer = int j = 2 * (b + dual)
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int j = 2 * (b + dual)
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double wd_real = data[j]
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double wd_real = data[j]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 31
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double wd_real = data[j]
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double wd_imag = data[j + 1]
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double wd_imag = data[j + 1]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 32
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double wd_imag = data[j + 1]
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int i = 2 * b
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2 * b
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = 2 * b
   [enerjc] *** EXPAX_ST: visitIdent: tree = b
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = b
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(b__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> i__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(i, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int j = 2 * (b + dual)
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2 * (b + dual)
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = 2 * (b + dual)
   [enerjc] *** EXPAX_ST: visitBinary: tree = b + dual
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = b + dual
   [enerjc] *** EXPAX_ST: visitIdent: tree = b
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = b
   [enerjc] *** EXPAX_ST: visitIdent: tree = dual
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = dual
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int j = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2, (enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(b__REF__, false).intValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(dual__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> j__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(j, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double wd_real = data[j]
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[j]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[j])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double wd_real = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 33
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double wd_real = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> wd_real__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(wd_real, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double wd_imag = data[j + 1]
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[j + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[j + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = j + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = j + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double wd_imag = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 34
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double wd_imag = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> wd_imag__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(wd_imag, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitAssign: tree = data[j] = data[i] - wd_real
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = data[j]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 35
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[j]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[j])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitBinary: tree = data[i] - wd_real
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = data[i] - wd_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 36
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[i]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[i])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 37
   [enerjc] *** ENERJ_APPROX(loadArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = wd_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = wd_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 38
   [enerjc] *** ENERJ_APPROX(loadlocal): wd_real
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), true).doubleValue() - enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(wd_real__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()]
   [enerjc] *** ENERJ_APPROX(storeArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()] = (double)enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(wd_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitAssign: tree = data[j + 1] = data[i + 1] - wd_imag
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = data[j + 1]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 39
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[j + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[j + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = j + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = j + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: visitBinary: tree = data[i + 1] - wd_imag
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = data[i + 1] - wd_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 40
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[i + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[i + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = i + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = i + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 41
   [enerjc] *** ENERJ_APPROX(loadArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = wd_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = wd_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 42
   [enerjc] *** ENERJ_APPROX(loadlocal): wd_imag
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), true).doubleValue() - enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(wd_imag__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** ENERJ_APPROX(storeArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()] = (double)enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(wd_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitAssignop: tree = data[i] += wd_real
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[i]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[i])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = wd_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = wd_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 43
   [enerjc] *** ENERJ_APPROX(loadlocal): wd_real
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #2
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitAssignop: tree = data[i + 1] += wd_imag
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[i + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[i + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = i + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = i + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = wd_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = wd_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 44
   [enerjc] *** ENERJ_APPROX(loadlocal): wd_imag
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #2
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_PRT: createNewInitializer = int a = 1
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int a = 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int a = 1
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int a = 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> a__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(a, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = a < dual
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = a < dual
   [enerjc] *** EXPAX_ST: visitIdent: tree = a
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = a
   [enerjc] *** EXPAX_ST: visitIdent: tree = dual
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = dual
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitUnary: tree = a++
   [enerjc] *** EXPAX_ST: visitUnary: tag = POSTINC
   [enerjc] *** EXPAX_ST: visitUnary: kind = POSTFIX_INCREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = a
   [enerjc] *** EXPAX_ST: visitIdent: tree = a
   [enerjc] *** EXPAX_ST: lvalues contains a
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = a
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double tmp_real = w_real - s * w_imag - s2 * w_real
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double tmp_real = w_real - s * w_imag - s2 * w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 45
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double tmp_real = w_real - s * w_imag - s2 * w_real
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double tmp_imag = w_imag + s * w_real - s2 * w_imag
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double tmp_imag = w_imag + s * w_real - s2 * w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 46
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double tmp_imag = w_imag + s * w_real - s2 * w_imag
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double tmp_real = w_real - s * w_imag - s2 * w_real
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitBinary: tree = w_real - s * w_imag - s2 * w_real
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = w_real - s * w_imag - s2 * w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 47
   [enerjc] *** EXPAX_ST: visitBinary: tree = w_real - s * w_imag
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = w_real - s * w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 48
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 49
   [enerjc] *** ENERJ_APPROX(loadlocal): w_real
   [enerjc] *** EXPAX_ST: visitBinary: tree = s * w_imag
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = s * w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 50
   [enerjc] *** EXPAX_ST: visitIdent: tree = s
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = s
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 51
   [enerjc] *** ENERJ_APPROX(loadlocal): s
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 52
   [enerjc] *** ENERJ_APPROX(loadlocal): w_imag
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s__REF__, true).doubleValue() * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue() - enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitBinary: tree = s2 * w_real
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = s2 * w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 53
   [enerjc] *** EXPAX_ST: visitIdent: tree = s2
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = s2
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 54
   [enerjc] *** ENERJ_APPROX(loadlocal): s2
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 55
   [enerjc] *** ENERJ_APPROX(loadlocal): w_real
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s2__REF__, true).doubleValue() * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue() - enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s2__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double tmp_real = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s2__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 56
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double tmp_real = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s2__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> tmp_real__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(tmp_real, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double tmp_imag = w_imag + s * w_real - s2 * w_imag
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitBinary: tree = w_imag + s * w_real - s2 * w_imag
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = w_imag + s * w_real - s2 * w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 57
   [enerjc] *** EXPAX_ST: visitBinary: tree = w_imag + s * w_real
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is true = PLUS
   [enerjc] *** EXPAX_PRT: approx is true = w_imag + s * w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 58
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 59
   [enerjc] *** ENERJ_APPROX(loadlocal): w_imag
   [enerjc] *** EXPAX_ST: visitBinary: tree = s * w_real
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = s * w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 60
   [enerjc] *** EXPAX_ST: visitIdent: tree = s
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = s
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 61
   [enerjc] *** ENERJ_APPROX(loadlocal): s
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 62
   [enerjc] *** ENERJ_APPROX(loadlocal): w_real
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s__REF__, true).doubleValue() * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue() + enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitBinary: tree = s2 * w_imag
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = s2 * w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 63
   [enerjc] *** EXPAX_ST: visitIdent: tree = s2
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = s2
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 64
   [enerjc] *** ENERJ_APPROX(loadlocal): s2
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 65
   [enerjc] *** ENERJ_APPROX(loadlocal): w_imag
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s2__REF__, true).doubleValue() * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue() - enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s2__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double tmp_imag = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s2__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 66
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double tmp_imag = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(s2__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> tmp_imag__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(tmp_imag, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitAssign: tree = w_real = tmp_real
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 67
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_real
   [enerjc] *** EXPAX_ST: lvalues contains w_real
   [enerjc] *** EXPAX_ST: visitIdent: tree = tmp_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = tmp_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 68
   [enerjc] *** ENERJ_APPROX(loadlocal): tmp_real
   [enerjc] *** EXPAX_ST: check oldLhs = w_real
   [enerjc] *** ENERJ_APPROX(storeLocal): w_real__REF__.value = (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(tmp_real__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitAssign: tree = w_imag = tmp_imag
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 69
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_imag
   [enerjc] *** EXPAX_ST: lvalues contains w_imag
   [enerjc] *** EXPAX_ST: visitIdent: tree = tmp_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = tmp_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 70
   [enerjc] *** ENERJ_APPROX(loadlocal): tmp_imag
   [enerjc] *** EXPAX_ST: check oldLhs = w_imag
   [enerjc] *** ENERJ_APPROX(storeLocal): w_imag__REF__.value = (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(tmp_imag__REF__, true).doubleValue()
   [enerjc] *** EXPAX_PRT: createNewInitializer = int b = 0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int b = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int b = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int b = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> b__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(b, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = b < n
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = b < n
   [enerjc] *** EXPAX_ST: visitIdent: tree = b
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = b
   [enerjc] *** EXPAX_ST: visitIdent: tree = n
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = n
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitAssignop: tree = b += 2 * dual
   [enerjc] *** EXPAX_ST: visitIdent: tree = b
   [enerjc] *** EXPAX_ST: lvalues contains b
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2 * dual
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = 2 * dual
   [enerjc] *** EXPAX_ST: visitIdent: tree = dual
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = dual
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = b
   [enerjc] *** EXPAX_PRT: createNewInitializer = int i = 2 * (b + a)
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 2 * (b + a)
   [enerjc] *** EXPAX_PRT: createNewInitializer = int j = 2 * (b + a + dual)
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int j = 2 * (b + a + dual)
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double z1_real = data[j]
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double z1_real = data[j]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 71
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double z1_real = data[j]
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double z1_imag = data[j + 1]
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double z1_imag = data[j + 1]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 72
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double z1_imag = data[j + 1]
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double wd_real = w_real * z1_real - w_imag * z1_imag
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double wd_real = w_real * z1_real - w_imag * z1_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 73
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double wd_real = w_real * z1_real - w_imag * z1_imag
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double wd_imag = w_real * z1_imag + w_imag * z1_real
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double wd_imag = w_real * z1_imag + w_imag * z1_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 74
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double wd_imag = w_real * z1_imag + w_imag * z1_real
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int i = 2 * (b + a)
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2 * (b + a)
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = 2 * (b + a)
   [enerjc] *** EXPAX_ST: visitBinary: tree = b + a
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = b + a
   [enerjc] *** EXPAX_ST: visitIdent: tree = b
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = b
   [enerjc] *** EXPAX_ST: visitIdent: tree = a
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = a
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2, (enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(b__REF__, false).intValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(a__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> i__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(i, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int j = 2 * (b + a + dual)
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2 * (b + a + dual)
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = 2 * (b + a + dual)
   [enerjc] *** EXPAX_ST: visitBinary: tree = b + a + dual
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = b + a + dual
   [enerjc] *** EXPAX_ST: visitBinary: tree = b + a
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = b + a
   [enerjc] *** EXPAX_ST: visitIdent: tree = b
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = b
   [enerjc] *** EXPAX_ST: visitIdent: tree = a
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = a
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitIdent: tree = dual
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = dual
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int j = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2, (enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(b__REF__, false).intValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(a__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(dual__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> j__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(j, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double z1_real = data[j]
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[j]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[j])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double z1_real = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 75
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double z1_real = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> z1_real__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(z1_real, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double z1_imag = data[j + 1]
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[j + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[j + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = j + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = j + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double z1_imag = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 76
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double z1_imag = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> z1_imag__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(z1_imag, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double wd_real = w_real * z1_real - w_imag * z1_imag
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitBinary: tree = w_real * z1_real - w_imag * z1_imag
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = w_real * z1_real - w_imag * z1_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 77
   [enerjc] *** EXPAX_ST: visitBinary: tree = w_real * z1_real
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = w_real * z1_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 78
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 79
   [enerjc] *** ENERJ_APPROX(loadlocal): w_real
   [enerjc] *** EXPAX_ST: visitIdent: tree = z1_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = z1_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 80
   [enerjc] *** ENERJ_APPROX(loadlocal): z1_real
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue() * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_real__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitBinary: tree = w_imag * z1_imag
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = w_imag * z1_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 81
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 82
   [enerjc] *** ENERJ_APPROX(loadlocal): w_imag
   [enerjc] *** EXPAX_ST: visitIdent: tree = z1_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = z1_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 83
   [enerjc] *** ENERJ_APPROX(loadlocal): z1_imag
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue() * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_imag__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue() - enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double wd_real = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 84
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double wd_real = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> wd_real__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(wd_real, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double wd_imag = w_real * z1_imag + w_imag * z1_real
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitBinary: tree = w_real * z1_imag + w_imag * z1_real
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is true = PLUS
   [enerjc] *** EXPAX_PRT: approx is true = w_real * z1_imag + w_imag * z1_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 85
   [enerjc] *** EXPAX_ST: visitBinary: tree = w_real * z1_imag
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = w_real * z1_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 86
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 87
   [enerjc] *** ENERJ_APPROX(loadlocal): w_real
   [enerjc] *** EXPAX_ST: visitIdent: tree = z1_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = z1_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 88
   [enerjc] *** ENERJ_APPROX(loadlocal): z1_imag
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue() * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_imag__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitBinary: tree = w_imag * z1_real
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is true = MUL
   [enerjc] *** EXPAX_PRT: approx is true = w_imag * z1_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 89
   [enerjc] *** EXPAX_ST: visitIdent: tree = w_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = w_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 90
   [enerjc] *** ENERJ_APPROX(loadlocal): w_imag
   [enerjc] *** EXPAX_ST: visitIdent: tree = z1_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = z1_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 91
   [enerjc] *** ENERJ_APPROX(loadlocal): z1_real
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue() * enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_real__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue() + enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double wd_imag = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 92
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double wd_imag = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(w_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(z1_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> wd_imag__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(wd_imag, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitAssign: tree = data[j] = data[i] - wd_real
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = data[j]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 93
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[j]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[j])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitBinary: tree = data[i] - wd_real
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = data[i] - wd_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 94
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[i]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[i])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 95
   [enerjc] *** ENERJ_APPROX(loadArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = wd_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = wd_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 96
   [enerjc] *** ENERJ_APPROX(loadlocal): wd_real
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), true).doubleValue() - enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(wd_real__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()]
   [enerjc] *** ENERJ_APPROX(storeArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue()] = (double)enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(wd_real__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitAssign: tree = data[j + 1] = data[i + 1] - wd_imag
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = data[j + 1]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 97
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[j + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[j + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = j + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = j + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: visitBinary: tree = data[i + 1] - wd_imag
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = MINUS
   [enerjc] *** EXPAX_PRT: approx is true = data[i + 1] - wd_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 98
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[i + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[i + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = i + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = i + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 99
   [enerjc] *** ENERJ_APPROX(loadArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = wd_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = wd_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 100
   [enerjc] *** ENERJ_APPROX(loadlocal): wd_imag
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** ENERJ_APPROX(visitBinary): enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), true).doubleValue() - enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(wd_imag__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** ENERJ_APPROX(storeArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()] = (double)enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), true).doubleValue(), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(wd_imag__REF__, true).doubleValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitAssignop: tree = data[i] += wd_real
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[i]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[i])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = wd_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = wd_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 101
   [enerjc] *** ENERJ_APPROX(loadlocal): wd_real
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #2
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitAssignop: tree = data[i + 1] += wd_imag
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[i + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[i + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = i + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = i + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = wd_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = wd_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 102
   [enerjc] *** ENERJ_APPROX(loadlocal): wd_imag
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #2
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] protected static void bitreverse(@Approx()
   [enerjc] double[] data) {
   [enerjc]     int n = data.length / 2;
   [enerjc]     int nm1 = n - 1;
   [enerjc]     int i = 0;
   [enerjc]     int j = 0;
   [enerjc]     for (; i < nm1; i++) {
   [enerjc]         int ii = i << 1;
   [enerjc]         int jj = j << 1;
   [enerjc]         int k = n >> 1;
   [enerjc]         if (i < j) {
   [enerjc]             @Approx()
   [enerjc]             double tmp_real = data[ii];
   [enerjc]             @Approx()
   [enerjc]             double tmp_imag = data[ii + 1];
   [enerjc]             data[ii] = data[jj];
   [enerjc]             data[ii + 1] = data[jj + 1];
   [enerjc]             data[jj] = tmp_real;
   [enerjc]             data[jj + 1] = tmp_imag;
   [enerjc]         }
   [enerjc]         while (k <= j) {
   [enerjc]             j -= k;
   [enerjc]             k >>= 1;
   [enerjc]         }
   [enerjc]         j += k;
   [enerjc]     }
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to bitreverse(double[])
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double[] data
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_PRT: createNewInitializer = int n = data.length / 2
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int n = data.length / 2
   [enerjc] *** EXPAX_PRT: createNewInitializer = int nm1 = n - 1
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int nm1 = n - 1
   [enerjc] *** EXPAX_PRT: createNewInitializer = int i = 0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 0
   [enerjc] *** EXPAX_PRT: createNewInitializer = int j = 0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int j = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<double[]> data__REF__ = new <double[]>enerj.rt.Reference<double[]>(data, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int n = data.length / 2
   [enerjc] *** EXPAX_ST: visitBinary: tree = data.length / 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is false = DIV
   [enerjc] *** EXPAX_PRT: approx is false = data.length / 2
   [enerjc] *** EXPAX_ST: visitSelect: tree = data.length
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int n = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false).length, 2, enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> n__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(n, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int nm1 = n - 1
   [enerjc] *** EXPAX_ST: visitBinary: tree = n - 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = n - 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = n
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = n
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int nm1 = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(n__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> nm1__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(nm1, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int i = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> i__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(i, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int j = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int j = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> j__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(j, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = i < nm1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = i < nm1
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = nm1
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = nm1
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitUnary: tree = i++
   [enerjc] *** EXPAX_ST: visitUnary: tag = POSTINC
   [enerjc] *** EXPAX_ST: visitUnary: kind = POSTFIX_INCREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: lvalues contains i
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_PRT: createNewInitializer = int ii = i << 1
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int ii = i << 1
   [enerjc] *** EXPAX_PRT: createNewInitializer = int jj = j << 1
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int jj = j << 1
   [enerjc] *** EXPAX_PRT: createNewInitializer = int k = n >> 1
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int k = n >> 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int ii = i << 1
   [enerjc] *** EXPAX_ST: visitBinary: tree = i << 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = SL
   [enerjc] *** EXPAX_ST: kind = LEFT_SHIFT
   [enerjc] *** EXPAX_PRT: approx is false = SL
   [enerjc] *** EXPAX_PRT: approx is false = i << 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int ii = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue() << 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> ii__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(ii, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int jj = j << 1
   [enerjc] *** EXPAX_ST: visitBinary: tree = j << 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = SL
   [enerjc] *** EXPAX_ST: kind = LEFT_SHIFT
   [enerjc] *** EXPAX_PRT: approx is false = SL
   [enerjc] *** EXPAX_PRT: approx is false = j << 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int jj = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(j__REF__, false).intValue() << 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> jj__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(jj, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int k = n >> 1
   [enerjc] *** EXPAX_ST: visitBinary: tree = n >> 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = SR
   [enerjc] *** EXPAX_ST: kind = RIGHT_SHIFT
   [enerjc] *** EXPAX_PRT: approx is false = SR
   [enerjc] *** EXPAX_PRT: approx is false = n >> 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = n
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = n
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int k = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(n__REF__, false).intValue() >> 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> k__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(k, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = i < j
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = i < j
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double tmp_real = data[ii]
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double tmp_real = data[ii]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 103
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double tmp_real = data[ii]
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double tmp_imag = data[ii + 1]
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double tmp_imag = data[ii + 1]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 104
   [enerjc] *** ENERJ_APPROX(createNewInitializer): approx createNew = @Approx()
   [enerjc] double tmp_imag = data[ii + 1]
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double tmp_real = data[ii]
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[ii]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[ii])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = ii
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = ii
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double tmp_real = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 105
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double tmp_real = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> tmp_real__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(tmp_real, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double tmp_imag = data[ii + 1]
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[ii + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[ii + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = ii + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = ii + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = ii
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = ii
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is true = VARDEF
   [enerjc] *** EXPAX_PRT: approx is true = @Approx()
   [enerjc] double tmp_imag = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 106
   [enerjc] *** ENERJ_APPROX(storeCall): @Approx()
   [enerjc] double tmp_imag = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<java.lang.Double> tmp_imag__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(tmp_imag, true, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitAssign: tree = data[ii] = data[jj]
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = data[ii]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 107
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[ii]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[ii])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = ii
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = ii
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[jj]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[jj])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = jj
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jj
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue()]
   [enerjc] *** ENERJ_APPROX(storeArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue()] = (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_ST: visitAssign: tree = data[ii + 1] = data[jj + 1]
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = data[ii + 1]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 108
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[ii + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[ii + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = ii + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = ii + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = ii
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = ii
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[jj + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[jj + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = jj + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = jj + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = jj
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jj
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** ENERJ_APPROX(storeArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(ii__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()] = (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadArray(enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false), enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), false).doubleValue()
   [enerjc] *** EXPAX_ST: visitAssign: tree = data[jj] = tmp_real
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = data[jj]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 109
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[jj]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[jj])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitIdent: tree = jj
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jj
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = tmp_real
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = tmp_real
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 110
   [enerjc] *** ENERJ_APPROX(loadlocal): tmp_real
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue()]
   [enerjc] *** ENERJ_APPROX(storeArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue()] = (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(tmp_real__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitAssign: tree = data[jj + 1] = tmp_imag
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = data[jj + 1]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 111
   [enerjc] *** EXPAX_ST: visitIndexed: tree = data[jj + 1]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=data[jj + 1])
   [enerjc] *** EXPAX_ST: visitIdent: tree = data
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = data
   [enerjc] *** EXPAX_ST: visitBinary: tree = jj + 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = jj + 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = jj
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jj
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = tmp_imag
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is true = IDENT
   [enerjc] *** EXPAX_PRT: approx is true = tmp_imag
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 112
   [enerjc] *** ENERJ_APPROX(loadlocal): tmp_imag
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()]
   [enerjc] *** ENERJ_APPROX(storeArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(data__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(jj__REF__, false).intValue(), 1, enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()] = (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadLocal(tmp_imag__REF__, true).doubleValue()
   [enerjc] *** EXPAX_ST: visitBinary: tree = k <= j
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LE
   [enerjc] *** EXPAX_ST: kind = LESS_THAN_EQUAL
   [enerjc] *** EXPAX_PRT: approx is false = LE
   [enerjc] *** EXPAX_PRT: approx is false = k <= j
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitAssignop: tree = j -= k
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: lvalues contains j
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: visitAssignop: tree = k >>= 1
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: lvalues contains k
   [enerjc] *** EXPAX_ST: visitAssignop: tree = j += k
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: lvalues contains j
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_PC: SimulationTranslator end!
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Void.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuilder.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/CharSequence.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AbstractStringBuilder.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuffer.class)]]
   [enerjc] [wrote RegularFileObject[/Users/jspark/projects/expax.code/apps/fft-enerj/build/jnt/scimark2/FFT.class]]
   [enerjc] [checking jnt.scimark2.Random]
   [enerjc] *** EXPAX_PC: ENERJ
   [enerjc] *** EXPAX_PC: MethodBindingTranslator start!
   [enerjc] *** EXPAX_PC: MethodBindingTranslator end!
   [enerjc] *** EXPAX_PC: RuntimePrecisionTranslator start!
   [enerjc] *** EXPAX_RPT: class name is changed to = jnt.scimark2.Random
   [enerjc] *** EXPAX_RPT: method name is changed to =  
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public <init>() {
   [enerjc]     super();
   [enerjc]     initialize(123456);
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to <init>()
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public <init>(double left, double right) {
   [enerjc]     super();
   [enerjc]     initialize(123456);
   [enerjc]     this.left = left;
   [enerjc]     this.right = right;
   [enerjc]     width = right - left;
   [enerjc]     haveRange = true;
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to <init>(double,double)
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public <init>(int seed) {
   [enerjc]     super();
   [enerjc]     initialize(seed);
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to <init>(int)
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public <init>(int seed, double left, double right) {
   [enerjc]     super();
   [enerjc]     initialize(seed);
   [enerjc]     this.left = left;
   [enerjc]     this.right = right;
   [enerjc]     width = right - left;
   [enerjc]     haveRange = true;
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to <init>(int,double,double)
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] @Approx()
   [enerjc] public final synchronized double nextDouble() {
   [enerjc]     int k;
   [enerjc]     double nextValue;
   [enerjc]     k = m[i] - m[j];
   [enerjc]     if (k < 0) k += m1;
   [enerjc]     m[j] = k;
   [enerjc]     if (i == 0) i = 16; else i--;
   [enerjc]     if (j == 0) j = 16; else j--;
   [enerjc]     if (haveRange) return left + dm1 * k * width; else return dm1 * k;
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to nextDouble()
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] private void initialize(int seed) {
   [enerjc]     int jseed;
   [enerjc]     int k0;
   [enerjc]     int k1;
   [enerjc]     int j0;
   [enerjc]     int j1;
   [enerjc]     int iloop;
   [enerjc]     this.seed = seed;
   [enerjc]     m = new int[17];
   [enerjc]     jseed = Math.min(Math.abs(seed), m1);
   [enerjc]     if (jseed % 2 == 0) --jseed;
   [enerjc]     k0 = 9069 % m2;
   [enerjc]     k1 = 9069 / m2;
   [enerjc]     j0 = jseed % m2;
   [enerjc]     j1 = jseed / m2;
   [enerjc]     for (iloop = 0; iloop < 17; ++iloop) {
   [enerjc]         jseed = j0 * k0;
   [enerjc]         j1 = (jseed / m2 + j0 * k1 + j1 * k0) % (m2 / 2);
   [enerjc]         j0 = jseed % m2;
   [enerjc]         m[iloop] = j0 + m2 * j1;
   [enerjc]     }
   [enerjc]     i = 4;
   [enerjc]     j = 16;
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to initialize(int)
   [enerjc] *** EXPAX_RPT: visitNewArray = new int[17]
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 4
   [enerjc] *** EXPAX_PC: RuntimePrecisionTranslator end!
   [enerjc] *** EXPAX_PC: SimulationTranslator start!
   [enerjc] *** EXPAX_ST: visitSelect: tree = jnt.scimark2
   [enerjc] *** EXPAX_ST: visitIdent: tree = jnt
   [enerjc] *** EXPAX_ST: lvalues contains jnt
   [enerjc] *** EXPAX_ST: lvalues contains = jnt.scimark2
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.lang.*
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.lang
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.lang
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.lang.*
   [enerjc] *** EXPAX_PRT: class name is changed to = jnt.scimark2.Random
   [enerjc] *** EXPAX_RPT: method name is changed to =  
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int seed = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int seed = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private int[] m
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private int i = 4
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private int i = 4
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private int j = 16
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private int j = 16
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private final int mdig = 32
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private int mdig = 32
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private final int one = 1
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private int one = 1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private final int m1 = (one << mdig - 2) + ((one << mdig - 2) - one)
   [enerjc] *** EXPAX_ST: visitBinary: tree = (one << mdig - 2) + ((one << mdig - 2) - one)
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = (one << mdig - 2) + ((one << mdig - 2) - one)
   [enerjc] *** EXPAX_ST: visitBinary: tree = one << mdig - 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = SL
   [enerjc] *** EXPAX_ST: kind = LEFT_SHIFT
   [enerjc] *** EXPAX_PRT: approx is false = SL
   [enerjc] *** EXPAX_PRT: approx is false = one << mdig - 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = one
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = one
   [enerjc] *** EXPAX_ST: visitBinary: tree = mdig - 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = mdig - 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = mdig
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = mdig
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitBinary: tree = (one << mdig - 2) - one
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = (one << mdig - 2) - one
   [enerjc] *** EXPAX_ST: visitBinary: tree = one << mdig - 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = SL
   [enerjc] *** EXPAX_ST: kind = LEFT_SHIFT
   [enerjc] *** EXPAX_PRT: approx is false = SL
   [enerjc] *** EXPAX_PRT: approx is false = one << mdig - 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = one
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = one
   [enerjc] *** EXPAX_ST: visitBinary: tree = mdig - 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = mdig - 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = mdig
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = mdig
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitIdent: tree = one
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = one
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private int m1 = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp((enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "one", false).intValue() << enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "mdig", false).intValue(), 2, enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()), (enerj.rt.PrecisionRuntimeRoot.impl.binaryOp((enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "one", false).intValue() << enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "mdig", false).intValue(), 2, enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()), enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "one", false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.MINUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()), enerj.rt.PrecisionRuntime.ArithOperator.PLUS, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private final int m2 = one << mdig / 2
   [enerjc] *** EXPAX_ST: visitBinary: tree = one << mdig / 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = SL
   [enerjc] *** EXPAX_ST: kind = LEFT_SHIFT
   [enerjc] *** EXPAX_PRT: approx is false = SL
   [enerjc] *** EXPAX_PRT: approx is false = one << mdig / 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = one
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = one
   [enerjc] *** EXPAX_ST: visitBinary: tree = mdig / 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is false = DIV
   [enerjc] *** EXPAX_PRT: approx is false = mdig / 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = mdig
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = mdig
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private int m2 = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "one", false).intValue() << enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "mdig", false).intValue(), 2, enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private double dm1 = 1.0 / (double)m1
   [enerjc] *** EXPAX_ST: visitBinary: tree = 1.0 / (double)m1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is false = DIV
   [enerjc] *** EXPAX_PRT: approx is false = 1.0 / (double)m1
   [enerjc] *** EXPAX_ST: visitIdent: tree = m1
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m1
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private double dm1 = enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(1.0, (double)enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "m1", false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.DIVIDE, enerj.rt.PrecisionRuntime.NumberKind.DOUBLE, false).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private boolean haveRange = false
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private boolean haveRange = false
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private double left = 0.0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private double left = 0.0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private double right = 1.0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private double right = 1.0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = private double width = 1.0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = private double width = 1.0
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public <init>() {
   [enerjc]     super();
   [enerjc]     enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor(this);
   [enerjc]     initialize(123456);
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to <init>()
   [enerjc] *** EXPAX_ST: visitIdent: tree = super
   [enerjc] *** EXPAX_ST: lvalues contains super
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_ST: visitIdent: tree = initialize
   [enerjc] *** EXPAX_ST: lvalues contains initialize
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public <init>(double left, double right) {
   [enerjc]     super();
   [enerjc]     enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor(this);
   [enerjc]     initialize(123456);
   [enerjc]     this.left = left;
   [enerjc]     this.right = right;
   [enerjc]     width = right - left;
   [enerjc]     haveRange = true;
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to <init>(double,double)
   [enerjc] *** EXPAX_PRT: createNewInitializer = double left
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = double left
   [enerjc] *** EXPAX_PRT: createNewInitializer = double right
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = double right
   [enerjc] *** EXPAX_ST: visitVarDef: tree = double left
   [enerjc] *** EXPAX_ST: visitVarDef: tree = double right
   [enerjc] *** EXPAX_ST: visitIdent: tree = super
   [enerjc] *** EXPAX_ST: lvalues contains super
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Double> right__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(right, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Double> left__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(left, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_ST: visitIdent: tree = initialize
   [enerjc] *** EXPAX_ST: lvalues contains initialize
   [enerjc] *** EXPAX_ST: visitAssign: tree = this.left = left
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = this.left
   [enerjc] *** EXPAX_ST: visitSelect: tree = this.left
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_ST: lvalues contains = this.left
   [enerjc] *** EXPAX_ST: visitIdent: tree = left
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = left
   [enerjc] *** EXPAX_ST: visitAssign: tree = this.right = right
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = this.right
   [enerjc] *** EXPAX_ST: visitSelect: tree = this.right
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_ST: lvalues contains = this.right
   [enerjc] *** EXPAX_ST: visitIdent: tree = right
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = right
   [enerjc] *** EXPAX_ST: visitAssign: tree = width = right - left
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = width
   [enerjc] *** EXPAX_ST: visitIdent: tree = width
   [enerjc] *** EXPAX_ST: lvalues contains width
   [enerjc] *** EXPAX_ST: visitBinary: tree = right - left
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = right - left
   [enerjc] *** EXPAX_ST: visitIdent: tree = right
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = right
   [enerjc] *** EXPAX_ST: visitIdent: tree = left
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = left
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitAssign: tree = haveRange = true
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = haveRange
   [enerjc] *** EXPAX_ST: visitIdent: tree = haveRange
   [enerjc] *** EXPAX_ST: lvalues contains haveRange
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public <init>(int seed) {
   [enerjc]     super();
   [enerjc]     enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor(this);
   [enerjc]     initialize(seed);
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to <init>(int)
   [enerjc] *** EXPAX_PRT: createNewInitializer = int seed
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int seed
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int seed
   [enerjc] *** EXPAX_ST: visitIdent: tree = super
   [enerjc] *** EXPAX_ST: lvalues contains super
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> seed__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(seed, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_ST: visitIdent: tree = initialize
   [enerjc] *** EXPAX_ST: lvalues contains initialize
   [enerjc] *** EXPAX_ST: visitIdent: tree = seed
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = seed
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public <init>(int seed, double left, double right) {
   [enerjc]     super();
   [enerjc]     enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor(this);
   [enerjc]     initialize(seed);
   [enerjc]     this.left = left;
   [enerjc]     this.right = right;
   [enerjc]     width = right - left;
   [enerjc]     haveRange = true;
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to <init>(int,double,double)
   [enerjc] *** EXPAX_PRT: createNewInitializer = int seed
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int seed
   [enerjc] *** EXPAX_PRT: createNewInitializer = double left
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = double left
   [enerjc] *** EXPAX_PRT: createNewInitializer = double right
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = double right
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int seed
   [enerjc] *** EXPAX_ST: visitVarDef: tree = double left
   [enerjc] *** EXPAX_ST: visitVarDef: tree = double right
   [enerjc] *** EXPAX_ST: visitIdent: tree = super
   [enerjc] *** EXPAX_ST: lvalues contains super
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Double> right__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(right, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Double> left__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(left, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> seed__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(seed, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_ST: visitIdent: tree = initialize
   [enerjc] *** EXPAX_ST: lvalues contains initialize
   [enerjc] *** EXPAX_ST: visitIdent: tree = seed
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = seed
   [enerjc] *** EXPAX_ST: visitAssign: tree = this.left = left
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = this.left
   [enerjc] *** EXPAX_ST: visitSelect: tree = this.left
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_ST: lvalues contains = this.left
   [enerjc] *** EXPAX_ST: visitIdent: tree = left
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = left
   [enerjc] *** EXPAX_ST: visitAssign: tree = this.right = right
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = this.right
   [enerjc] *** EXPAX_ST: visitSelect: tree = this.right
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_ST: lvalues contains = this.right
   [enerjc] *** EXPAX_ST: visitIdent: tree = right
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = right
   [enerjc] *** EXPAX_ST: visitAssign: tree = width = right - left
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = width
   [enerjc] *** EXPAX_ST: visitIdent: tree = width
   [enerjc] *** EXPAX_ST: lvalues contains width
   [enerjc] *** EXPAX_ST: visitBinary: tree = right - left
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = right - left
   [enerjc] *** EXPAX_ST: visitIdent: tree = right
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = right
   [enerjc] *** EXPAX_ST: visitIdent: tree = left
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = left
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitAssign: tree = haveRange = true
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = haveRange
   [enerjc] *** EXPAX_ST: visitIdent: tree = haveRange
   [enerjc] *** EXPAX_ST: lvalues contains haveRange
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] @Approx()
   [enerjc] public final synchronized double nextDouble() {
   [enerjc]     int k;
   [enerjc]     double nextValue;
   [enerjc]     k = m[i] - m[j];
   [enerjc]     if (k < 0) k += m1;
   [enerjc]     m[j] = k;
   [enerjc]     if (i == 0) i = 16; else i--;
   [enerjc]     if (j == 0) j = 16; else j--;
   [enerjc]     if (haveRange) return left + dm1 * k * width; else return dm1 * k;
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to nextDouble()
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_PRT: createNewInitializer = int k
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int k
   [enerjc] *** EXPAX_PRT: createNewInitializer = double nextValue
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = double nextValue
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int k
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> k__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(null, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = double nextValue
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Double> nextValue__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(null, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitAssign: tree = k = m[i] - m[j]
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: lvalues contains k
   [enerjc] *** EXPAX_ST: visitBinary: tree = m[i] - m[j]
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MINUS
   [enerjc] *** EXPAX_ST: kind = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = MINUS
   [enerjc] *** EXPAX_PRT: approx is false = m[i] - m[j]
   [enerjc] *** EXPAX_ST: visitIndexed: tree = m[i]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=m[i])
   [enerjc] *** EXPAX_ST: visitIdent: tree = m
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<int[]>loadField(this, "m", false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "i", false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<int[]>loadField(this, "m", false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "i", false).intValue()]
   [enerjc] *** EXPAX_ST: visitIndexed: tree = m[j]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=m[j])
   [enerjc] *** EXPAX_ST: visitIdent: tree = m
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<int[]>loadField(this, "m", false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "j", false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<int[]>loadField(this, "m", false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "j", false).intValue()]
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: check oldLhs = k
   [enerjc] *** EXPAX_ST: visitBinary: tree = k < 0
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = k < 0
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitAssignop: tree = k += m1
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: lvalues contains k
   [enerjc] *** EXPAX_ST: visitIdent: tree = m1
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m1
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: visitAssign: tree = m[j] = k
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = m[j]
   [enerjc] *** EXPAX_ST: visitIndexed: tree = m[j]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=m[j])
   [enerjc] *** EXPAX_ST: visitIdent: tree = m
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<int[]>loadField(this, "m", false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "j", false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<int[]>loadField(this, "m", false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "j", false).intValue()]
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<int[]>loadField(this, "m", false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(this, "j", false).intValue()]
   [enerjc] *** EXPAX_ST: visitBinary: tree = i == 0
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = EQ
   [enerjc] *** EXPAX_ST: kind = EQUAL_TO
   [enerjc] *** EXPAX_PRT: approx is false = EQ
   [enerjc] *** EXPAX_PRT: approx is false = i == 0
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitAssign: tree = i = 16
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: lvalues contains i
   [enerjc] *** EXPAX_ST: visitUnary: tree = i--
   [enerjc] *** EXPAX_ST: visitUnary: tag = POSTDEC
   [enerjc] *** EXPAX_ST: visitUnary: kind = POSTFIX_DECREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: lvalues contains i
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #3
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitBinary: tree = j == 0
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = EQ
   [enerjc] *** EXPAX_ST: kind = EQUAL_TO
   [enerjc] *** EXPAX_PRT: approx is false = EQ
   [enerjc] *** EXPAX_PRT: approx is false = j == 0
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitAssign: tree = j = 16
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: lvalues contains j
   [enerjc] *** EXPAX_ST: visitUnary: tree = j--
   [enerjc] *** EXPAX_ST: visitUnary: tag = POSTDEC
   [enerjc] *** EXPAX_ST: visitUnary: kind = POSTFIX_DECREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: lvalues contains j
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #3
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: visitIdent: tree = haveRange
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = haveRange
   [enerjc] *** EXPAX_ST: visitBinary: tree = left + dm1 * k * width
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = left + dm1 * k * width
   [enerjc] *** EXPAX_ST: visitIdent: tree = left
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = left
   [enerjc] *** EXPAX_ST: visitBinary: tree = dm1 * k * width
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = dm1 * k * width
   [enerjc] *** EXPAX_ST: visitBinary: tree = dm1 * k
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = dm1 * k
   [enerjc] *** EXPAX_ST: visitIdent: tree = dm1
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = dm1
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitIdent: tree = width
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = width
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitBinary: tree = dm1 * k
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = dm1 * k
   [enerjc] *** EXPAX_ST: visitIdent: tree = dm1
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = dm1
   [enerjc] *** EXPAX_ST: visitIdent: tree = k
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] private void initialize(int seed) {
   [enerjc]     int jseed;
   [enerjc]     int k0;
   [enerjc]     int k1;
   [enerjc]     int j0;
   [enerjc]     int j1;
   [enerjc]     int iloop;
   [enerjc]     this.seed = seed;
   [enerjc]     m = enerj.rt.PrecisionRuntimeRoot.impl.newArray(new int[17], 1, false, 4, 0);
   [enerjc]     jseed = Math.min(Math.abs(seed), m1);
   [enerjc]     if (jseed % 2 == 0) --jseed;
   [enerjc]     k0 = 9069 % m2;
   [enerjc]     k1 = 9069 / m2;
   [enerjc]     j0 = jseed % m2;
   [enerjc]     j1 = jseed / m2;
   [enerjc]     for (iloop = 0; iloop < 17; ++iloop) {
   [enerjc]         jseed = j0 * k0;
   [enerjc]         j1 = (jseed / m2 + j0 * k1 + j1 * k0) % (m2 / 2);
   [enerjc]         j0 = jseed % m2;
   [enerjc]         m[iloop] = j0 + m2 * j1;
   [enerjc]     }
   [enerjc]     i = 4;
   [enerjc]     j = 16;
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to initialize(int)
   [enerjc] *** EXPAX_PRT: createNewInitializer = int seed
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int seed
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int seed
   [enerjc] *** EXPAX_PRT: createNewInitializer = int jseed
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int jseed
   [enerjc] *** EXPAX_PRT: createNewInitializer = int k0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int k0
   [enerjc] *** EXPAX_PRT: createNewInitializer = int k1
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int k1
   [enerjc] *** EXPAX_PRT: createNewInitializer = int j0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int j0
   [enerjc] *** EXPAX_PRT: createNewInitializer = int j1
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int j1
   [enerjc] *** EXPAX_PRT: createNewInitializer = int iloop
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int iloop
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> seed__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(seed, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int jseed
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> jseed__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(null, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int k0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> k0__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(null, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int k1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> k1__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(null, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int j0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> j0__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(null, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int j1
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> j1__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(null, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int iloop
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> iloop__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(null, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitAssign: tree = this.seed = seed
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = this.seed
   [enerjc] *** EXPAX_ST: visitSelect: tree = this.seed
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_ST: lvalues contains = this.seed
   [enerjc] *** EXPAX_ST: visitIdent: tree = seed
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = seed
   [enerjc] *** EXPAX_ST: visitAssign: tree = m = enerj.rt.PrecisionRuntimeRoot.impl.newArray(new int[17], 1, false, 4, 0)
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m
   [enerjc] *** EXPAX_ST: visitIdent: tree = m
   [enerjc] *** EXPAX_ST: lvalues contains m
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.newArray
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitAssign: tree = jseed = Math.min(Math.abs(seed), m1)
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jseed
   [enerjc] *** EXPAX_ST: visitIdent: tree = jseed
   [enerjc] *** EXPAX_ST: lvalues contains jseed
   [enerjc] *** EXPAX_ST: visitSelect: tree = Math.min
   [enerjc] *** EXPAX_ST: visitIdent: tree = Math
   [enerjc] *** EXPAX_ST: lvalues contains Math
   [enerjc] *** EXPAX_ST: lvalues contains = Math.min
   [enerjc] *** EXPAX_ST: visitSelect: tree = Math.abs
   [enerjc] *** EXPAX_ST: visitIdent: tree = Math
   [enerjc] *** EXPAX_ST: lvalues contains Math
   [enerjc] *** EXPAX_ST: lvalues contains = Math.abs
   [enerjc] *** EXPAX_ST: visitIdent: tree = seed
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = seed
   [enerjc] *** EXPAX_ST: visitIdent: tree = m1
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m1
   [enerjc] *** EXPAX_ST: check oldLhs = jseed
   [enerjc] *** EXPAX_ST: visitBinary: tree = jseed % 2 == 0
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = EQ
   [enerjc] *** EXPAX_ST: kind = EQUAL_TO
   [enerjc] *** EXPAX_PRT: approx is false = EQ
   [enerjc] *** EXPAX_PRT: approx is false = jseed % 2 == 0
   [enerjc] *** EXPAX_ST: visitBinary: tree = jseed % 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MOD
   [enerjc] *** EXPAX_ST: kind = REMAINDER
   [enerjc] *** EXPAX_PRT: approx is false = MOD
   [enerjc] *** EXPAX_PRT: approx is false = jseed % 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = jseed
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jseed
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitUnary: tree = --jseed
   [enerjc] *** EXPAX_ST: visitUnary: tag = PREDEC
   [enerjc] *** EXPAX_ST: visitUnary: kind = PREFIX_DECREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jseed
   [enerjc] *** EXPAX_ST: visitIdent: tree = jseed
   [enerjc] *** EXPAX_ST: lvalues contains jseed
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jseed
   [enerjc] *** EXPAX_ST: visitAssign: tree = k0 = 9069 % m2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k0
   [enerjc] *** EXPAX_ST: visitIdent: tree = k0
   [enerjc] *** EXPAX_ST: lvalues contains k0
   [enerjc] *** EXPAX_ST: visitBinary: tree = 9069 % m2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MOD
   [enerjc] *** EXPAX_ST: kind = REMAINDER
   [enerjc] *** EXPAX_PRT: approx is false = MOD
   [enerjc] *** EXPAX_PRT: approx is false = 9069 % m2
   [enerjc] *** EXPAX_ST: visitIdent: tree = m2
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m2
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: check oldLhs = k0
   [enerjc] *** EXPAX_ST: visitAssign: tree = k1 = 9069 / m2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k1
   [enerjc] *** EXPAX_ST: visitIdent: tree = k1
   [enerjc] *** EXPAX_ST: lvalues contains k1
   [enerjc] *** EXPAX_ST: visitBinary: tree = 9069 / m2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is false = DIV
   [enerjc] *** EXPAX_PRT: approx is false = 9069 / m2
   [enerjc] *** EXPAX_ST: visitIdent: tree = m2
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m2
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: check oldLhs = k1
   [enerjc] *** EXPAX_ST: visitAssign: tree = j0 = jseed % m2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j0
   [enerjc] *** EXPAX_ST: visitIdent: tree = j0
   [enerjc] *** EXPAX_ST: lvalues contains j0
   [enerjc] *** EXPAX_ST: visitBinary: tree = jseed % m2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MOD
   [enerjc] *** EXPAX_ST: kind = REMAINDER
   [enerjc] *** EXPAX_PRT: approx is false = MOD
   [enerjc] *** EXPAX_PRT: approx is false = jseed % m2
   [enerjc] *** EXPAX_ST: visitIdent: tree = jseed
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jseed
   [enerjc] *** EXPAX_ST: visitIdent: tree = m2
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m2
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: check oldLhs = j0
   [enerjc] *** EXPAX_ST: visitAssign: tree = j1 = jseed / m2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j1
   [enerjc] *** EXPAX_ST: visitIdent: tree = j1
   [enerjc] *** EXPAX_ST: lvalues contains j1
   [enerjc] *** EXPAX_ST: visitBinary: tree = jseed / m2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is false = DIV
   [enerjc] *** EXPAX_PRT: approx is false = jseed / m2
   [enerjc] *** EXPAX_ST: visitIdent: tree = jseed
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jseed
   [enerjc] *** EXPAX_ST: visitIdent: tree = m2
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m2
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: check oldLhs = j1
   [enerjc] *** EXPAX_ST: visitAssign: tree = iloop = 0
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = iloop
   [enerjc] *** EXPAX_ST: visitIdent: tree = iloop
   [enerjc] *** EXPAX_ST: lvalues contains iloop
   [enerjc] *** EXPAX_ST: check oldLhs = iloop
   [enerjc] *** EXPAX_ST: visitBinary: tree = iloop < 17
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = iloop < 17
   [enerjc] *** EXPAX_ST: visitIdent: tree = iloop
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = iloop
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitUnary: tree = ++iloop
   [enerjc] *** EXPAX_ST: visitUnary: tag = PREINC
   [enerjc] *** EXPAX_ST: visitUnary: kind = PREFIX_INCREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = iloop
   [enerjc] *** EXPAX_ST: visitIdent: tree = iloop
   [enerjc] *** EXPAX_ST: lvalues contains iloop
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = iloop
   [enerjc] *** EXPAX_ST: visitAssign: tree = jseed = j0 * k0
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jseed
   [enerjc] *** EXPAX_ST: visitIdent: tree = jseed
   [enerjc] *** EXPAX_ST: lvalues contains jseed
   [enerjc] *** EXPAX_ST: visitBinary: tree = j0 * k0
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = j0 * k0
   [enerjc] *** EXPAX_ST: visitIdent: tree = j0
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j0
   [enerjc] *** EXPAX_ST: visitIdent: tree = k0
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k0
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: check oldLhs = jseed
   [enerjc] *** EXPAX_ST: visitAssign: tree = j1 = (jseed / m2 + j0 * k1 + j1 * k0) % (m2 / 2)
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j1
   [enerjc] *** EXPAX_ST: visitIdent: tree = j1
   [enerjc] *** EXPAX_ST: lvalues contains j1
   [enerjc] *** EXPAX_ST: visitBinary: tree = (jseed / m2 + j0 * k1 + j1 * k0) % (m2 / 2)
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MOD
   [enerjc] *** EXPAX_ST: kind = REMAINDER
   [enerjc] *** EXPAX_PRT: approx is false = MOD
   [enerjc] *** EXPAX_PRT: approx is false = (jseed / m2 + j0 * k1 + j1 * k0) % (m2 / 2)
   [enerjc] *** EXPAX_ST: visitBinary: tree = jseed / m2 + j0 * k1 + j1 * k0
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = jseed / m2 + j0 * k1 + j1 * k0
   [enerjc] *** EXPAX_ST: visitBinary: tree = jseed / m2 + j0 * k1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = jseed / m2 + j0 * k1
   [enerjc] *** EXPAX_ST: visitBinary: tree = jseed / m2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is false = DIV
   [enerjc] *** EXPAX_PRT: approx is false = jseed / m2
   [enerjc] *** EXPAX_ST: visitIdent: tree = jseed
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jseed
   [enerjc] *** EXPAX_ST: visitIdent: tree = m2
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m2
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitBinary: tree = j0 * k1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = j0 * k1
   [enerjc] *** EXPAX_ST: visitIdent: tree = j0
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j0
   [enerjc] *** EXPAX_ST: visitIdent: tree = k1
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k1
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitBinary: tree = j1 * k0
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = j1 * k0
   [enerjc] *** EXPAX_ST: visitIdent: tree = j1
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j1
   [enerjc] *** EXPAX_ST: visitIdent: tree = k0
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = k0
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitBinary: tree = m2 / 2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = DIV
   [enerjc] *** EXPAX_ST: kind = DIVIDE
   [enerjc] *** EXPAX_PRT: approx is false = DIV
   [enerjc] *** EXPAX_PRT: approx is false = m2 / 2
   [enerjc] *** EXPAX_ST: visitIdent: tree = m2
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m2
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: check oldLhs = j1
   [enerjc] *** EXPAX_ST: visitAssign: tree = j0 = jseed % m2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j0
   [enerjc] *** EXPAX_ST: visitIdent: tree = j0
   [enerjc] *** EXPAX_ST: lvalues contains j0
   [enerjc] *** EXPAX_ST: visitBinary: tree = jseed % m2
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MOD
   [enerjc] *** EXPAX_ST: kind = REMAINDER
   [enerjc] *** EXPAX_PRT: approx is false = MOD
   [enerjc] *** EXPAX_PRT: approx is false = jseed % m2
   [enerjc] *** EXPAX_ST: visitIdent: tree = jseed
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = jseed
   [enerjc] *** EXPAX_ST: visitIdent: tree = m2
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m2
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: check oldLhs = j0
   [enerjc] *** EXPAX_ST: visitAssign: tree = m[iloop] = j0 + m2 * j1
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = m[iloop]
   [enerjc] *** EXPAX_ST: visitIndexed: tree = m[iloop]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=m[iloop])
   [enerjc] *** EXPAX_ST: visitIdent: tree = m
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m
   [enerjc] *** EXPAX_ST: visitIdent: tree = iloop
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = iloop
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<int[]>loadField(this, "m", false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(iloop__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<int[]>loadField(this, "m", false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(iloop__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitBinary: tree = j0 + m2 * j1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = j0 + m2 * j1
   [enerjc] *** EXPAX_ST: visitIdent: tree = j0
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j0
   [enerjc] *** EXPAX_ST: visitBinary: tree = m2 * j1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = m2 * j1
   [enerjc] *** EXPAX_ST: visitIdent: tree = m2
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = m2
   [enerjc] *** EXPAX_ST: visitIdent: tree = j1
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j1
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<int[]>loadField(this, "m", false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(iloop__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitAssign: tree = i = 4
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: lvalues contains i
   [enerjc] *** EXPAX_ST: visitAssign: tree = j = 16
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = j
   [enerjc] *** EXPAX_ST: visitIdent: tree = j
   [enerjc] *** EXPAX_ST: lvalues contains j
   [enerjc] *** EXPAX_PC: SimulationTranslator end!
   [enerjc] *** EXPAX_PC: ENERJ
   [enerjc] *** EXPAX_PC: MethodBindingTranslator start!
   [enerjc] *** EXPAX_PC: MethodBindingTranslator end!
   [enerjc] *** EXPAX_PC: RuntimePrecisionTranslator start!
   [enerjc] *** EXPAX_RPT: class name is changed to = jnt.scimark2.commandline
   [enerjc] *** EXPAX_RPT: method name is changed to =  
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public <init>() {
   [enerjc]     super();
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to <init>()
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public static void main(String[] args) {
   [enerjc]     double min_time = Constants.RESOLUTION_DEFAULT;
   [enerjc]     int FFT_size = Constants.TINY_FFT_SIZE;
   [enerjc]     String benchSel = null;
   [enerjc]     String seed = null;
   [enerjc]     if (args.length != 1) throw new RuntimeException("Error! Seed should be provided as an argument");
   [enerjc]     seed = args[0];
   [enerjc]     Random R = new Random(Integer.parseInt(seed));
   [enerjc]     kernel.measureFFT(FFT_size, min_time, R);
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to main(java.lang.String[])
   [enerjc] *** EXPAX_RPT: visitNewClass = new RuntimeException("Error! Seed should be provided as an argument")
   [enerjc] *** EXPAX_PC: objectSizes called - type = @Precise RuntimeException
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 8
   [enerjc] *** EXPAX_RPT: visitNewClass = new Random(Integer.parseInt(seed))
   [enerjc] *** EXPAX_PC: objectSizes called - type = @Precise Random
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 4
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 0
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 4
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 4
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 4
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 4
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 4
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 4
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 8
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 1
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 8
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 8
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: preciseSize += 8
   [enerjc] *** EXPAX_PC: RuntimePrecisionTranslator end!
   [enerjc] *** EXPAX_PC: SimulationTranslator start!
   [enerjc] *** EXPAX_ST: visitSelect: tree = jnt.scimark2
   [enerjc] *** EXPAX_ST: visitIdent: tree = jnt
   [enerjc] *** EXPAX_ST: lvalues contains jnt
   [enerjc] *** EXPAX_ST: lvalues contains = jnt.scimark2
   [enerjc] *** EXPAX_ST: visitSelect: tree = java.util.Properties
   [enerjc] *** EXPAX_ST: visitSelect: tree = java.util
   [enerjc] *** EXPAX_ST: visitIdent: tree = java
   [enerjc] *** EXPAX_ST: lvalues contains java
   [enerjc] *** EXPAX_ST: lvalues contains = java.util
   [enerjc] *** EXPAX_ST: lvalues contains = java.util.Properties
   [enerjc] *** EXPAX_PRT: class name is changed to = jnt.scimark2.commandline
   [enerjc] *** EXPAX_RPT: method name is changed to =  
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public <init>() {
   [enerjc]     super();
   [enerjc]     enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor(this);
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to <init>()
   [enerjc] *** EXPAX_ST: visitIdent: tree = super
   [enerjc] *** EXPAX_ST: lvalues contains super
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public static void main(String[] args) {
   [enerjc]     double min_time = Constants.RESOLUTION_DEFAULT;
   [enerjc]     int FFT_size = Constants.TINY_FFT_SIZE;
   [enerjc]     String benchSel = null;
   [enerjc]     String seed = null;
   [enerjc]     if (args.length != 1) throw enerj.rt.PrecisionRuntimeRoot.impl.wrappedNew(enerj.rt.PrecisionRuntimeRoot.impl.beforeCreation(Thread.currentThread(), false, 16, 0), new RuntimeException("Error! Seed should be provided as an argument"), Thread.currentThread());
   [enerjc]     seed = args[0];
   [enerjc]     Random R = enerj.rt.PrecisionRuntimeRoot.impl.wrappedNew(enerj.rt.PrecisionRuntimeRoot.impl.beforeCreation(Thread.currentThread(), false, 69, 0), new Random(Integer.parseInt(seed)), Thread.currentThread());
   [enerjc]     kernel.measureFFT(FFT_size, min_time, R);
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to main(java.lang.String[])
   [enerjc] *** EXPAX_PRT: createNewInitializer = String[] args
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = String[] args
   [enerjc] *** EXPAX_ST: visitVarDef: tree = String[] args
   [enerjc] *** EXPAX_ST: visitIdent: tree = String
   [enerjc] *** EXPAX_ST: lvalues contains String
   [enerjc] *** EXPAX_PRT: createNewInitializer = double min_time = Constants.RESOLUTION_DEFAULT
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = double min_time = Constants.RESOLUTION_DEFAULT
   [enerjc] *** EXPAX_PRT: createNewInitializer = int FFT_size = Constants.TINY_FFT_SIZE
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int FFT_size = Constants.TINY_FFT_SIZE
   [enerjc] *** EXPAX_PRT: createNewInitializer = String benchSel = null
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = String benchSel = null
   [enerjc] *** EXPAX_PRT: createNewInitializer = String seed = null
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = String seed = null
   [enerjc] *** EXPAX_PRT: createNewInitializer = Random R = enerj.rt.PrecisionRuntimeRoot.impl.wrappedNew(enerj.rt.PrecisionRuntimeRoot.impl.beforeCreation(Thread.currentThread(), false, 69, 0), new Random(Integer.parseInt(seed)), Thread.currentThread())
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = Random R = enerj.rt.PrecisionRuntimeRoot.impl.wrappedNew(enerj.rt.PrecisionRuntimeRoot.impl.beforeCreation(Thread.currentThread(), false, 69, 0), new Random(Integer.parseInt(seed)), Thread.currentThread())
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<String[]> args__REF__ = new <String[]>enerj.rt.Reference<String[]>(args, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = double min_time = Constants.RESOLUTION_DEFAULT
   [enerjc] *** EXPAX_ST: visitSelect: tree = Constants.RESOLUTION_DEFAULT
   [enerjc] *** EXPAX_ST: visitIdent: tree = Constants
   [enerjc] *** EXPAX_ST: lvalues contains Constants
   [enerjc] *** EXPAX_ST: call isApprox - visitSelect
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = Constants.RESOLUTION_DEFAULT
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = double min_time = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Double>loadField(Constants.class, "RESOLUTION_DEFAULT", false).doubleValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Double> min_time__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(min_time, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int FFT_size = Constants.TINY_FFT_SIZE
   [enerjc] *** EXPAX_ST: visitSelect: tree = Constants.TINY_FFT_SIZE
   [enerjc] *** EXPAX_ST: visitIdent: tree = Constants
   [enerjc] *** EXPAX_ST: lvalues contains Constants
   [enerjc] *** EXPAX_ST: call isApprox - visitSelect
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = Constants.TINY_FFT_SIZE
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int FFT_size = enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadField(Constants.class, "TINY_FFT_SIZE", false).intValue()
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> FFT_size__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(FFT_size, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = String benchSel = null
   [enerjc] *** EXPAX_ST: visitIdent: tree = String
   [enerjc] *** EXPAX_ST: lvalues contains String
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = String benchSel = null
   [enerjc] [wrote RegularFileObject[/Users/jspark/projects/expax.code/apps/fft-enerj/build/jnt/scimark2/Random.class]]
   [enerjc] [checking jnt.scimark2.commandline]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/NumberFormatException.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalArgumentException.class)]]
   [enerjc] [wrote RegularFileObject[/Users/jspark/projects/expax.code/apps/fft-enerj/build/jnt/scimark2/commandline.class]]
   [enerjc] [checking jnt.scimark2.kernel]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class)]]
   [enerjc] [loading ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class)]]
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<String> benchSel__REF__ = new <String>enerj.rt.Reference<String>(benchSel, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = String seed = null
   [enerjc] *** EXPAX_ST: visitIdent: tree = String
   [enerjc] *** EXPAX_ST: lvalues contains String
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = String seed = null
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<String> seed__REF__ = new <String>enerj.rt.Reference<String>(seed, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = args.length != 1
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = NE
   [enerjc] *** EXPAX_ST: kind = NOT_EQUAL_TO
   [enerjc] *** EXPAX_PRT: approx is false = NE
   [enerjc] *** EXPAX_PRT: approx is false = args.length != 1
   [enerjc] *** EXPAX_ST: visitSelect: tree = args.length
   [enerjc] *** EXPAX_ST: visitIdent: tree = args
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = args
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.wrappedNew
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.beforeCreation
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitSelect: tree = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitIdent: tree = Thread
   [enerjc] *** EXPAX_ST: lvalues contains Thread
   [enerjc] *** EXPAX_ST: lvalues contains = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitIdent: tree = RuntimeException
   [enerjc] *** EXPAX_ST: lvalues contains RuntimeException
   [enerjc] *** EXPAX_ST: visitSelect: tree = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitIdent: tree = Thread
   [enerjc] *** EXPAX_ST: lvalues contains Thread
   [enerjc] *** EXPAX_ST: lvalues contains = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitAssign: tree = seed = args[0]
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = seed
   [enerjc] *** EXPAX_ST: visitIdent: tree = seed
   [enerjc] *** EXPAX_ST: lvalues contains seed
   [enerjc] *** EXPAX_ST: visitSelect: tree = .java.lang.String
   [enerjc] *** EXPAX_ST: visitSelect: tree = .java.lang
   [enerjc] *** EXPAX_ST: visitSelect: tree = .java
   [enerjc] *** EXPAX_ST: visitIdent: tree = 
   [enerjc] *** EXPAX_ST: lvalues contains 
   [enerjc] *** EXPAX_ST: lvalues contains = .java
   [enerjc] *** EXPAX_ST: lvalues contains = .java.lang
   [enerjc] *** EXPAX_ST: lvalues contains = .java.lang.String
   [enerjc] *** EXPAX_ST: visitIndexed: tree = args[0]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=args[0])
   [enerjc] *** EXPAX_ST: visitIdent: tree = args
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = args
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<.java.lang.String[]>loadLocal(args__REF__, false)[0])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<.java.lang.String[]>loadLocal(args__REF__, false)[0]
   [enerjc] *** EXPAX_ST: check oldLhs = seed
   [enerjc] *** EXPAX_ST: visitVarDef: tree = Random R = enerj.rt.PrecisionRuntimeRoot.impl.wrappedNew(enerj.rt.PrecisionRuntimeRoot.impl.beforeCreation(Thread.currentThread(), false, 69, 0), new Random(Integer.parseInt(seed)), Thread.currentThread())
   [enerjc] *** EXPAX_ST: visitIdent: tree = Random
   [enerjc] *** EXPAX_ST: lvalues contains Random
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.wrappedNew
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.beforeCreation
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitSelect: tree = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitIdent: tree = Thread
   [enerjc] *** EXPAX_ST: lvalues contains Thread
   [enerjc] *** EXPAX_ST: lvalues contains = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitIdent: tree = Random
   [enerjc] *** EXPAX_ST: lvalues contains Random
   [enerjc] *** EXPAX_ST: visitSelect: tree = Integer.parseInt
   [enerjc] *** EXPAX_ST: visitIdent: tree = Integer
   [enerjc] *** EXPAX_ST: lvalues contains Integer
   [enerjc] *** EXPAX_ST: lvalues contains = Integer.parseInt
   [enerjc] *** EXPAX_ST: visitIdent: tree = seed
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = seed
   [enerjc] *** EXPAX_ST: visitSelect: tree = Thread.currentThread
   [enerjc] *** EXPAX_ST: visitIdent: tree = Thread
   [enerjc] *** EXPAX_ST: lvalues contains Thread
   [enerjc] *** EXPAX_ST: lvalues contains = Thread.currentThread
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = Random R = enerj.rt.PrecisionRuntimeRoot.impl.wrappedNew(enerj.rt.PrecisionRuntimeRoot.impl.beforeCreation(Thread.currentThread(), false, 69, 0), new Random(Integer.parseInt(enerj.rt.PrecisionRuntimeRoot.impl.<.java.lang.String>loadLocal(seed__REF__, false))), Thread.currentThread())
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<Random> R__REF__ = new <Random>enerj.rt.Reference<Random>(R, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitSelect: tree = kernel.measureFFT
   [enerjc] *** EXPAX_ST: visitIdent: tree = kernel
   [enerjc] *** EXPAX_ST: lvalues contains kernel
   [enerjc] *** EXPAX_ST: lvalues contains = kernel.measureFFT
   [enerjc] *** EXPAX_ST: visitIdent: tree = FFT_size
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = FFT_size
   [enerjc] *** EXPAX_ST: visitIdent: tree = min_time
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = min_time
   [enerjc] *** EXPAX_ST: visitIdent: tree = R
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = R
   [enerjc] *** EXPAX_PC: SimulationTranslator end!
   [enerjc] *** EXPAX_PC: ENERJ
   [enerjc] *** EXPAX_PC: MethodBindingTranslator start!
   [enerjc] *** EXPAX_PC: MethodBindingTranslator end!
   [enerjc] *** EXPAX_PC: RuntimePrecisionTranslator start!
   [enerjc] *** EXPAX_RPT: class name is changed to = jnt.scimark2.kernel
   [enerjc] *** EXPAX_RPT: method name is changed to =  
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public <init>() {
   [enerjc]     super();
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to <init>()
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] public static double measureFFT(int N, double mintime, Random R) {
   [enerjc]     System.out.println("measureFFT");
   [enerjc]     @Approx()
   [enerjc]     double[] x = RandomVector(2 * N, R);
   [enerjc]     long cycles = 100;
   [enerjc]     for (int i = 0; i < cycles; i++) {
   [enerjc]         FFT.transform(x);
   [enerjc]         FFT.inverse(x);
   [enerjc]         System.out.println("loop = " + i);
   [enerjc]     }
   [enerjc]     System.out.print("FFT vector: ");
   [enerjc]     for (int i = 0; i < N; ++i) {
   [enerjc]         System.out.print(Endorsements.endorse(x[i]) + " ");
   [enerjc]     }
   [enerjc]     System.out.println("");
   [enerjc]     return 0.0;
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to measureFFT(int,double,jnt.scimark2.Random)
   [enerjc] *** EXPAX_RPT: tree = 
   [enerjc] @Approx()
   [enerjc] private static double[] RandomVector(int N, Random R) {
   [enerjc]     @Approx()
   [enerjc]     double[] A = new  @Approx() double[N];
   [enerjc]     for (int i = 0; i < N; i++) A[i] = R.nextDouble();
   [enerjc]     return A;
   [enerjc] }
   [enerjc] *** EXPAX_RPT: method name is changed to RandomVector(int,jnt.scimark2.Random)
   [enerjc] *** EXPAX_RPT: visitNewArray = new  @Approx() double[N]
   [enerjc] *** EXPAX_PC: typeSizes called
   [enerjc] *** EXPAX_PC: approxSize += 8
   [enerjc] *** ENERJ_APPROX: new  @Approx() double[N]
   [enerjc] *** EXPAX_PC: RuntimePrecisionTranslator end!
   [enerjc] *** EXPAX_PC: SimulationTranslator start!
   [enerjc] *** EXPAX_ST: visitSelect: tree = jnt.scimark2
   [enerjc] *** EXPAX_ST: visitIdent: tree = jnt
   [enerjc] *** EXPAX_ST: lvalues contains jnt
   [enerjc] *** EXPAX_ST: lvalues contains = jnt.scimark2
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.lang.*
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.lang
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.lang
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.lang.*
   [enerjc] *** EXPAX_PRT: class name is changed to = jnt.scimark2.kernel
   [enerjc] *** EXPAX_RPT: method name is changed to =  
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public <init>() {
   [enerjc]     super();
   [enerjc]     enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor(this);
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to <init>()
   [enerjc] *** EXPAX_ST: visitIdent: tree = super
   [enerjc] *** EXPAX_ST: lvalues contains super
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.enterConstructor
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = this
   [enerjc] *** EXPAX_ST: lvalues contains this
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] public static double measureFFT(int N, double mintime, Random R) {
   [enerjc]     System.out.println("measureFFT");
   [enerjc]     @Approx()
   [enerjc]     double[] x = RandomVector(2 * N, R);
   [enerjc]     long cycles = 100;
   [enerjc]     for (int i = 0; i < cycles; i++) {
   [enerjc]         FFT.transform(x);
   [enerjc]         FFT.inverse(x);
   [enerjc]         System.out.println("loop = " + i);
   [enerjc]     }
   [enerjc]     System.out.print("FFT vector: ");
   [enerjc]     for (int i = 0; i < N; ++i) {
   [enerjc]         System.out.print(Endorsements.endorse(x[i]) + " ");
   [enerjc]     }
   [enerjc]     System.out.println("");
   [enerjc]     return 0.0;
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to measureFFT(int,double,jnt.scimark2.Random)
   [enerjc] *** EXPAX_PRT: createNewInitializer = int N
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int N
   [enerjc] *** EXPAX_PRT: createNewInitializer = double mintime
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = double mintime
   [enerjc] *** EXPAX_PRT: createNewInitializer = Random R
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = Random R
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int N
   [enerjc] *** EXPAX_ST: visitVarDef: tree = double mintime
   [enerjc] *** EXPAX_ST: visitVarDef: tree = Random R
   [enerjc] *** EXPAX_ST: visitIdent: tree = Random
   [enerjc] *** EXPAX_ST: lvalues contains Random
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double[] x = RandomVector(2 * N, R)
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = @Approx()
   [enerjc] double[] x = RandomVector(2 * N, R)
   [enerjc] *** EXPAX_PRT: createNewInitializer = long cycles = 100
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = long cycles = 100
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<Random> R__REF__ = new <Random>enerj.rt.Reference<Random>(R, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Double> mintime__REF__ = new <java.lang.Double>enerj.rt.Reference<java.lang.Double>(mintime, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> N__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(N, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitSelect: tree = System.out.println
   [enerjc] *** EXPAX_ST: visitSelect: tree = System.out
   [enerjc] *** EXPAX_ST: visitIdent: tree = System
   [enerjc] *** EXPAX_ST: lvalues contains System
   [enerjc] *** EXPAX_ST: call isApprox - visitSelect
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = System.out
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double[] x = RandomVector(2 * N, R)
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitIdent: tree = RandomVector
   [enerjc] *** EXPAX_ST: lvalues contains RandomVector
   [enerjc] *** EXPAX_ST: visitBinary: tree = 2 * N
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = MUL
   [enerjc] *** EXPAX_ST: kind = MULTIPLY
   [enerjc] *** EXPAX_PRT: approx is false = MUL
   [enerjc] *** EXPAX_PRT: approx is false = 2 * N
   [enerjc] *** EXPAX_ST: visitIdent: tree = N
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = N
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitIdent: tree = R
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = R
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = @Approx()
   [enerjc] double[] x = RandomVector(enerj.rt.PrecisionRuntimeRoot.impl.binaryOp(2, enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(N__REF__, false).intValue(), enerj.rt.PrecisionRuntime.ArithOperator.MULTIPLY, enerj.rt.PrecisionRuntime.NumberKind.INT, false).intValue(), enerj.rt.PrecisionRuntimeRoot.impl.<.jnt.scimark2.Random>loadLocal(R__REF__, false))
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<double[]> x__REF__ = new <double[]>enerj.rt.Reference<double[]>(x, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = long cycles = 100
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = long cycles = 100
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Long> cycles__REF__ = new <java.lang.Long>enerj.rt.Reference<java.lang.Long>(cycles, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_PRT: createNewInitializer = int i = 0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int i = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> i__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(i, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = i < cycles
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = i < cycles
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = cycles
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = cycles
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitUnary: tree = i++
   [enerjc] *** EXPAX_ST: visitUnary: tag = POSTINC
   [enerjc] *** EXPAX_ST: visitUnary: kind = POSTFIX_INCREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: lvalues contains i
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitSelect: tree = FFT.transform
   [enerjc] *** EXPAX_ST: visitIdent: tree = FFT
   [enerjc] *** EXPAX_ST: lvalues contains FFT
   [enerjc] *** EXPAX_ST: lvalues contains = FFT.transform
   [enerjc] *** EXPAX_ST: visitIdent: tree = x
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = x
   [enerjc] *** EXPAX_ST: visitSelect: tree = FFT.inverse
   [enerjc] *** EXPAX_ST: visitIdent: tree = FFT
   [enerjc] *** EXPAX_ST: lvalues contains FFT
   [enerjc] *** EXPAX_ST: lvalues contains = FFT.inverse
   [enerjc] *** EXPAX_ST: visitIdent: tree = x
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = x
   [enerjc] *** EXPAX_ST: visitSelect: tree = System.out.println
   [enerjc] *** EXPAX_ST: visitSelect: tree = System.out
   [enerjc] *** EXPAX_ST: visitIdent: tree = System
   [enerjc] *** EXPAX_ST: lvalues contains System
   [enerjc] *** EXPAX_ST: call isApprox - visitSelect
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = System.out
   [enerjc] *** EXPAX_ST: visitBinary: tree = "loop = " + i
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = "loop = " + i
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitSelect: tree = System.out.print
   [enerjc] *** EXPAX_ST: visitSelect: tree = System.out
   [enerjc] *** EXPAX_ST: visitIdent: tree = System
   [enerjc] *** EXPAX_ST: lvalues contains System
   [enerjc] *** EXPAX_ST: call isApprox - visitSelect
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = System.out
   [enerjc] *** EXPAX_PRT: createNewInitializer = int i = 0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int i = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> i__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(i, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = i < N
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = i < N
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = N
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = N
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitUnary: tree = ++i
   [enerjc] *** EXPAX_ST: visitUnary: tag = PREINC
   [enerjc] *** EXPAX_ST: visitUnary: kind = PREFIX_INCREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: lvalues contains i
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitSelect: tree = System.out.print
   [enerjc] *** EXPAX_ST: visitSelect: tree = System.out
   [enerjc] *** EXPAX_ST: visitIdent: tree = System
   [enerjc] *** EXPAX_ST: lvalues contains System
   [enerjc] *** EXPAX_ST: call isApprox - visitSelect
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = System.out
   [enerjc] *** EXPAX_ST: visitBinary: tree = Endorsements.endorse(x[i]) + " "
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = PLUS
   [enerjc] *** EXPAX_ST: kind = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = PLUS
   [enerjc] *** EXPAX_PRT: approx is false = Endorsements.endorse(x[i]) + " "
   [enerjc] *** EXPAX_ST: visitSelect: tree = Endorsements.endorse
   [enerjc] *** EXPAX_ST: visitIdent: tree = Endorsements
   [enerjc] *** EXPAX_ST: lvalues contains Endorsements
   [enerjc] *** EXPAX_ST: lvalues contains = Endorsements.endorse
   [enerjc] *** EXPAX_ST: visitIndexed: tree = x[i]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=x[i])
   [enerjc] *** EXPAX_ST: visitIdent: tree = x
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = x
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(x__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: call isApprox - visitIndexed
   [enerjc] *** EXPAX_PRT: approx is false = INDEXED
   [enerjc] *** EXPAX_PRT: approx is false = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(x__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitSelect: tree = System.out.println
   [enerjc] *** EXPAX_ST: visitSelect: tree = System.out
   [enerjc] *** EXPAX_ST: visitIdent: tree = System
   [enerjc] *** EXPAX_ST: lvalues contains System
   [enerjc] *** EXPAX_ST: call isApprox - visitSelect
   [enerjc] *** EXPAX_PRT: approx is false = SELECT
   [enerjc] *** EXPAX_PRT: approx is false = System.out
   [enerjc] *** EXPAX_PRT method = 
   [enerjc] @Approx()
   [enerjc] private static double[] RandomVector(int N, Random R) {
   [enerjc]     @Approx()
   [enerjc]     double[] A = enerj.rt.PrecisionRuntimeRoot.impl.newArray(new  @Approx() double[N], 1, true, 0, 8);
   [enerjc]     for (int i = 0; i < N; i++) A[i] = R.nextDouble();
   [enerjc]     return A;
   [enerjc] }
   [enerjc] *** EXPAX_PRT: method name is changed to RandomVector(int,jnt.scimark2.Random)
   [enerjc] *** EXPAX_PRT: createNewInitializer = int N
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int N
   [enerjc] *** EXPAX_PRT: createNewInitializer = Random R
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = Random R
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int N
   [enerjc] *** EXPAX_ST: visitVarDef: tree = Random R
   [enerjc] *** EXPAX_ST: visitIdent: tree = Random
   [enerjc] *** EXPAX_ST: lvalues contains Random
   [enerjc] *** EXPAX_PRT: createNewInitializer = @Approx()
   [enerjc] double[] A = enerj.rt.PrecisionRuntimeRoot.impl.newArray(new  @Approx() double[N], 1, true, 0, 8)
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = @Approx()
   [enerjc] double[] A = enerj.rt.PrecisionRuntimeRoot.impl.newArray(new  @Approx() double[N], 1, true, 0, 8)
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<Random> R__REF__ = new <Random>enerj.rt.Reference<Random>(R, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> N__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(N, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] double[] A = enerj.rt.PrecisionRuntimeRoot.impl.newArray(new  @Approx() double[N], 1, true, 0, 8)
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl.newArray
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot.impl
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt.PrecisionRuntimeRoot
   [enerjc] *** EXPAX_ST: visitSelect: tree = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = enerj
   [enerjc] *** EXPAX_ST: lvalues contains enerj
   [enerjc] *** EXPAX_ST: lvalues contains = enerj.rt
   [enerjc] *** EXPAX_ST: visitIdent: tree = Approx
   [enerjc] *** EXPAX_ST: lvalues contains Approx
   [enerjc] *** EXPAX_ST: visitIdent: tree = N
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = N
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = @Approx()
   [enerjc] double[] A = enerj.rt.PrecisionRuntimeRoot.impl.newArray(new  @Approx() double[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(N__REF__, false).intValue()], 1, true, 0, 8)
   [enerjc] *** EXPAX_ST: visitVarDef: tree = @Approx()
   [enerjc] enerj.rt.Reference<double[]> A__REF__ = new <double[]>enerj.rt.Reference<double[]>(A, false, false)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_PRT: createNewInitializer = int i = 0
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = int i = 0
   [enerjc] *** EXPAX_ST: call isApprox  - storeCall
   [enerjc] *** EXPAX_PRT: approx is false = VARDEF
   [enerjc] *** EXPAX_PRT: approx is false = int i = 0
   [enerjc] *** EXPAX_ST: visitVarDef: tree = enerj.rt.Reference<java.lang.Integer> i__REF__ = new <java.lang.Integer>enerj.rt.Reference<java.lang.Integer>(i, false, true)
   [enerjc] *** EXPAX_ST: Don't instrument statements inserted by ReferencingTranslator.
   [enerjc] *** EXPAX_ST: visitBinary: tree = i < N
   [enerjc] *** EXPAX_ST: call isApprox - visitBinary
   [enerjc] *** EXPAX_ST: tag = LT
   [enerjc] *** EXPAX_ST: kind = LESS_THAN
   [enerjc] *** EXPAX_PRT: approx is false = LT
   [enerjc] *** EXPAX_PRT: approx is false = i < N
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = N
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = N
   [enerjc] *** EXPAX_ST: ident end?
   [enerjc] *** EXPAX_ST: visitUnary: tree = i++
   [enerjc] *** EXPAX_ST: visitUnary: tag = POSTINC
   [enerjc] *** EXPAX_ST: visitUnary: kind = POSTFIX_INCREMENT
   [enerjc] *** EXPAX_ST: call isApprox - visitUnary
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: lvalues contains i
   [enerjc] *** EXPAX_ST: assignopCall start
   [enerjc] *** EXPAX_ST: call isApprox - assignopCall #1
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: visitAssign: tree = A[i] = R.nextDouble()
   [enerjc] *** EXPAX_PRT: approx is true = INDEXED
   [enerjc] *** EXPAX_PRT: approx is true = A[i]
   [enerjc] *** EXPAX_PRT: isApprox return true: count = 1
   [enerjc] *** EXPAX_ST: visitIndexed: tree = A[i]
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag INCREASE = 1(node=A[i])
   [enerjc] *** EXPAX_ST: visitIdent: tree = A
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = A
   [enerjc] *** EXPAX_ST: visitIdent: tree = i
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = i
   [enerjc] *** EXPAX_ST: (visitIndexed) arrayAccessFlag DECREASE = 0(node=enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(A__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()])
   [enerjc] *** EXPAX_ST: lvalues contains enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(A__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** EXPAX_ST: visitSelect: tree = R.nextDouble
   [enerjc] *** EXPAX_ST: visitIdent: tree = R
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = R
   [enerjc] *** EXPAX_ST: check oldLhs = enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(A__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()]
   [enerjc] *** ENERJ_APPROX(storeArray): enerj.rt.PrecisionRuntimeRoot.impl.<double[]>loadLocal(A__REF__, false)[enerj.rt.PrecisionRuntimeRoot.impl.<java.lang.Integer>loadLocal(i__REF__, false).intValue()] = (double)enerj.rt.PrecisionRuntimeRoot.impl.<.jnt.scimark2.Random>loadLocal(R__REF__, false).nextDouble()
   [enerjc] *** EXPAX_ST: visitIdent: tree = A
   [enerjc] *** EXPAX_ST: call isApprox or expaxIsApprox - visitIdent #2
   [enerjc] *** EXPAX_PRT: approx is false = IDENT
   [enerjc] *** EXPAX_PRT: approx is false = A
   [enerjc] *** EXPAX_PC: SimulationTranslator end!
   [enerjc] [wrote RegularFileObject[/Users/jspark/projects/expax.code/apps/fft-enerj/build/jnt/scimark2/kernel.class]]
   [enerjc] [total 2791ms]
      [jar] Building jar: /Users/jspark/projects/expax.code/apps/fft-enerj/fft.jar

BUILD SUCCESSFUL
Total time: 3 seconds
